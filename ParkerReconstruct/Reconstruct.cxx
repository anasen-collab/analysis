//
// File generated by rootcint at Tue May  3 11:41:59 2016

// Do NOT change. Changes will be lost next time file is generated
//

#define R__DICTIONARY_FILENAME Reconstruct
#include "RConfig.h" //rootcint 4834
#if !defined(R__ACCESS_IN_SYMBOL)
//Break the privacy of classes -- Disabled for the moment
#define private public
#define protected public
#endif

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;
#include "Reconstruct.h"

#include "TCollectionProxyInfo.h"
#include "TClass.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"
#include "TFileMergeInfo.h"

// START OF SHADOWS

namespace ROOT {
   namespace Shadow {
      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::SiHit SiHit;
      #else
      class SiHit  {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::SiHit::SortByDetector SortByDetector;
         #else
         class SortByDetector  {
            public:
            //friend XX;
            int DetID; //
            int UpMult; //
            int DownMult; //
            int BackMult; //
            int HitType; //
            vector< Int_t > UpChNum; //
            vector< Int_t > DownChNum; //
            vector< Int_t > BackChNum; //
            vector< Double_t > EnergyUp_Raw; //
            vector< Double_t > EnergyDown_Raw; //
            vector< Double_t > EnergyBack_Raw; //
            vector< Double_t > EnergyUp_Pulser; //
            vector< Double_t > EnergyDown_Pulser; //
            vector< Double_t > EnergyBack_Pulser; //
            vector< Double_t > EnergyUp_Rel; //
            vector< Double_t > EnergyDown_Rel; //
            vector< Double_t > EnergyBack_Rel; //
            vector< Double_t > EnergyUp_Cal; //
            vector< Double_t > EnergyDown_Cal; //
            vector< Double_t > EnergyBack_Cal; //
            vector< Double_t > TimeUp; //
            vector< Double_t > TimeDown; //
            vector< Double_t > TimeBack; //
         };
         #endif

         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::SiHit::SortByHit SortByHit;
         #else
         class SortByHit  {
            public:
            //friend XX;
            int NHitsInDet; //
            int DetID; //
            int Flag; //
            int HitType; //
            double FrontChannel; //
            double BackChannel; //
            double EnergyBack; //
            double EnergyFront; //
            double Energy; //
            double Time; //
            double X; //
            double Y; //
            double Z; //
            double XW; //
            double YW; //
            double ZW; //
            double RW; //
            double PhiW; //
            double RFSubtract; //
            int TrackType; //
         };
         #endif

         int NSiHits; //
         SortByDetector det_place_holder; //
         SortByHit hit_place_holder; //
         vector< SortByDetector > Detector; //
         vector< SortByHit > Hit; //
         vector< SortByDetector >* ReadDet; //
         vector< SortByHit >* ReadHit; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::PCHit PCHit;
      #else
      class PCHit  {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::PCHit::SortByPC SortByPC;
         #else
         class SortByPC  {
            public:
            //friend XX;
            int WireID; //
            double Down; //
            double Up; //
            double DownVoltage; //
            double UpVoltage; //
            double Energy; //
            double Z; //
            double XW; //
            double YW; //
            double ZW; //
            double RW; //
            double PhiW; //
            int TrackType; //
         };
         #endif

         int NPCHits; //
         SortByPC pc_place_holder; //
         vector< SortByPC > Hit; //
         vector< SortByPC >* ReadHit; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::SETTINGS SETTINGS;
      #else
      class SETTINGS  {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::SETTINGS::set_values set_values;
         #else
         class set_values  {
            public:
            //friend XX;
            double X3Pulser_Offset[24][12]; //
            double X3Pulser_Slope[24][12]; //
            double X3RelativeGains[24][12]; //
            double X3FinalFix[24][12]; //
            double X3Geometry_Up[24][4][4]; //
            double X3Geometry_Down[24][4][4]; //
            double QQQPulser_Offset[4][32]; //
            double QQQPulser_Slope[4][32]; //
            double QQQRelativeGains[4][32]; //
            double QQQFinalFix[4][32]; //
            double SiAlphaCal[28]; //
         };
         #endif

         set_values set_val; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::Track Track;
      #else
      class Track  {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::Track::TrackEvent TrackEvent;
         #else
         class TrackEvent  {
            public:
            //friend XX;
            int TrackType; //
            int DetID; //
            int WireID; //
            double SiEnergy; //
            double SiZ; //
            double SiR; //
            double SiPhi; //
            double PCEnergy; //
            double PCZ; //
            double PCR; //
            double PCPhi; //
            double IntPoint; //
            double PathLength; //
            double Theta; //
            double Phi; //
            double BeamEnergy; //
            double PCZ_Ref; //
         };
         #endif

         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::Track::Silicon_Event Silicon_Event;
         #else
         class Silicon_Event  {
            public:
            //friend XX;
            int TrackType; //
            int DetID; //
            double SiEnergy; //
            double SiZ; //
            double SiR; //
            double SiPhi; //
         };
         #endif

         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::Track::PropCounter_Event PropCounter_Event;
         #else
         class PropCounter_Event  {
            public:
            //friend XX;
            int TrackType; //
            int WireID; //
            double PCEnergy; //
            double PCZ; //
            double PCR; //
            double PCPhi; //
         };
         #endif

         int NTracks; //
         int NTracks1; //
         int NTracks2; //
         int NTracks3; //
         TrackEvent track_place_holder; //
         Silicon_Event si_place_holder; //
         PropCounter_Event pc_place_holder; //
         vector< TrackEvent > TrEvent; //
         vector< TrackEvent >* ReadTrEvent; //
         vector< Silicon_Event > SiEvent; //
         vector< Silicon_Event >* ReadSiEvent; //
         vector< PropCounter_Event > PCEvent; //
         vector< PropCounter_Event >* ReadPCEvent; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::EnergyLoss EnergyLoss;
      #else
      class EnergyLoss  {
         public:
         //friend XX;
         bool GoodELossFile; //
         ::TGraph* EvD; //
         double c; //
         double* IonEnergy; //
         double IonMass; //
         double* dEdx_e; //
         double* dEdx_n; //
         int points; //
         int last_point; //
         bool Energy_in_range; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::Reconstruct Reconstruct;
      #else
      class Reconstruct  {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::Reconstruct::Be8Event Be8Event;
         #else
         class Be8Event  {
            public:
            //friend XX;
            double DiffIntPoint; //
            double SiEnergy_tot; //
            double PCEnergy_tot; //
            double Energy_tot; //
            double AlphaAngle; //
            double BeTheta; //
            double BePhi; //
            double BeKE; //
            double Ex; //
            double AvgBeamEnergy; //
         };
         #endif

         Be8Event BeEvent; //
      };
      #endif

   } // of namespace Shadow
} // of namespace ROOT
// END OF SHADOWS

namespace ROOT {
   void SiHit_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SiHit_Dictionary();
   static void *new_SiHit(void *p = 0);
   static void *newArray_SiHit(Long_t size, void *p);
   static void delete_SiHit(void *p);
   static void deleteArray_SiHit(void *p);
   static void destruct_SiHit(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SiHit*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::SiHit) == sizeof(::ROOT::Shadow::SiHit));
      ::SiHit *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SiHit),0);
      static ::ROOT::TGenericClassInfo 
         instance("SiHit", "./../Include/organizetree.h", 16,
                  typeid(::SiHit), DefineBehavior(ptr, ptr),
                  &SiHit_ShowMembers, &SiHit_Dictionary, isa_proxy, 4,
                  sizeof(::SiHit) );
      instance.SetNew(&new_SiHit);
      instance.SetNewArray(&newArray_SiHit);
      instance.SetDelete(&delete_SiHit);
      instance.SetDeleteArray(&deleteArray_SiHit);
      instance.SetDestructor(&destruct_SiHit);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SiHit*)
   {
      return GenerateInitInstanceLocal((::SiHit*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SiHit*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SiHit_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::SiHit*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void SiHitcLcLSortByDetector_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SiHitcLcLSortByDetector_Dictionary();
   static void *new_SiHitcLcLSortByDetector(void *p = 0);
   static void *newArray_SiHitcLcLSortByDetector(Long_t size, void *p);
   static void delete_SiHitcLcLSortByDetector(void *p);
   static void deleteArray_SiHitcLcLSortByDetector(void *p);
   static void destruct_SiHitcLcLSortByDetector(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SiHit::SortByDetector*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::SiHit::SortByDetector) == sizeof(::ROOT::Shadow::SiHit::SortByDetector));
      ::SiHit::SortByDetector *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SiHit::SortByDetector),0);
      static ::ROOT::TGenericClassInfo 
         instance("SiHit::SortByDetector", "./../Include/organizetree.h", 23,
                  typeid(::SiHit::SortByDetector), DefineBehavior(ptr, ptr),
                  &SiHitcLcLSortByDetector_ShowMembers, &SiHitcLcLSortByDetector_Dictionary, isa_proxy, 4,
                  sizeof(::SiHit::SortByDetector) );
      instance.SetNew(&new_SiHitcLcLSortByDetector);
      instance.SetNewArray(&newArray_SiHitcLcLSortByDetector);
      instance.SetDelete(&delete_SiHitcLcLSortByDetector);
      instance.SetDeleteArray(&deleteArray_SiHitcLcLSortByDetector);
      instance.SetDestructor(&destruct_SiHitcLcLSortByDetector);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SiHit::SortByDetector*)
   {
      return GenerateInitInstanceLocal((::SiHit::SortByDetector*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SiHit::SortByDetector*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SiHitcLcLSortByDetector_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::SiHit::SortByDetector*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void SiHitcLcLSortByHit_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SiHitcLcLSortByHit_Dictionary();
   static void *new_SiHitcLcLSortByHit(void *p = 0);
   static void *newArray_SiHitcLcLSortByHit(Long_t size, void *p);
   static void delete_SiHitcLcLSortByHit(void *p);
   static void deleteArray_SiHitcLcLSortByHit(void *p);
   static void destruct_SiHitcLcLSortByHit(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SiHit::SortByHit*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::SiHit::SortByHit) == sizeof(::ROOT::Shadow::SiHit::SortByHit));
      ::SiHit::SortByHit *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SiHit::SortByHit),0);
      static ::ROOT::TGenericClassInfo 
         instance("SiHit::SortByHit", "./../Include/organizetree.h", 52,
                  typeid(::SiHit::SortByHit), DefineBehavior(ptr, ptr),
                  &SiHitcLcLSortByHit_ShowMembers, &SiHitcLcLSortByHit_Dictionary, isa_proxy, 4,
                  sizeof(::SiHit::SortByHit) );
      instance.SetNew(&new_SiHitcLcLSortByHit);
      instance.SetNewArray(&newArray_SiHitcLcLSortByHit);
      instance.SetDelete(&delete_SiHitcLcLSortByHit);
      instance.SetDeleteArray(&deleteArray_SiHitcLcLSortByHit);
      instance.SetDestructor(&destruct_SiHitcLcLSortByHit);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SiHit::SortByHit*)
   {
      return GenerateInitInstanceLocal((::SiHit::SortByHit*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SiHit::SortByHit*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SiHitcLcLSortByHit_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::SiHit::SortByHit*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void PCHit_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void PCHit_Dictionary();
   static void *new_PCHit(void *p = 0);
   static void *newArray_PCHit(Long_t size, void *p);
   static void delete_PCHit(void *p);
   static void deleteArray_PCHit(void *p);
   static void destruct_PCHit(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PCHit*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::PCHit) == sizeof(::ROOT::Shadow::PCHit));
      ::PCHit *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PCHit),0);
      static ::ROOT::TGenericClassInfo 
         instance("PCHit", "./../Include/organizetree.h", 136,
                  typeid(::PCHit), DefineBehavior(ptr, ptr),
                  &PCHit_ShowMembers, &PCHit_Dictionary, isa_proxy, 4,
                  sizeof(::PCHit) );
      instance.SetNew(&new_PCHit);
      instance.SetNewArray(&newArray_PCHit);
      instance.SetDelete(&delete_PCHit);
      instance.SetDeleteArray(&deleteArray_PCHit);
      instance.SetDestructor(&destruct_PCHit);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PCHit*)
   {
      return GenerateInitInstanceLocal((::PCHit*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PCHit*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void PCHit_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::PCHit*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void PCHitcLcLSortByPC_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void PCHitcLcLSortByPC_Dictionary();
   static void *new_PCHitcLcLSortByPC(void *p = 0);
   static void *newArray_PCHitcLcLSortByPC(Long_t size, void *p);
   static void delete_PCHitcLcLSortByPC(void *p);
   static void deleteArray_PCHitcLcLSortByPC(void *p);
   static void destruct_PCHitcLcLSortByPC(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PCHit::SortByPC*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::PCHit::SortByPC) == sizeof(::ROOT::Shadow::PCHit::SortByPC));
      ::PCHit::SortByPC *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PCHit::SortByPC),0);
      static ::ROOT::TGenericClassInfo 
         instance("PCHit::SortByPC", "./../Include/organizetree.h", 143,
                  typeid(::PCHit::SortByPC), DefineBehavior(ptr, ptr),
                  &PCHitcLcLSortByPC_ShowMembers, &PCHitcLcLSortByPC_Dictionary, isa_proxy, 4,
                  sizeof(::PCHit::SortByPC) );
      instance.SetNew(&new_PCHitcLcLSortByPC);
      instance.SetNewArray(&newArray_PCHitcLcLSortByPC);
      instance.SetDelete(&delete_PCHitcLcLSortByPC);
      instance.SetDeleteArray(&deleteArray_PCHitcLcLSortByPC);
      instance.SetDestructor(&destruct_PCHitcLcLSortByPC);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PCHit::SortByPC*)
   {
      return GenerateInitInstanceLocal((::PCHit::SortByPC*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PCHit::SortByPC*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void PCHitcLcLSortByPC_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::PCHit::SortByPC*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void SETTINGS_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SETTINGS_Dictionary();
   static void *new_SETTINGS(void *p = 0);
   static void *newArray_SETTINGS(Long_t size, void *p);
   static void delete_SETTINGS(void *p);
   static void deleteArray_SETTINGS(void *p);
   static void destruct_SETTINGS(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SETTINGS*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::SETTINGS) == sizeof(::ROOT::Shadow::SETTINGS));
      ::SETTINGS *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SETTINGS),0);
      static ::ROOT::TGenericClassInfo 
         instance("SETTINGS", "./../Include/organizetree.h", 181,
                  typeid(::SETTINGS), DefineBehavior(ptr, ptr),
                  &SETTINGS_ShowMembers, &SETTINGS_Dictionary, isa_proxy, 4,
                  sizeof(::SETTINGS) );
      instance.SetNew(&new_SETTINGS);
      instance.SetNewArray(&newArray_SETTINGS);
      instance.SetDelete(&delete_SETTINGS);
      instance.SetDeleteArray(&deleteArray_SETTINGS);
      instance.SetDestructor(&destruct_SETTINGS);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SETTINGS*)
   {
      return GenerateInitInstanceLocal((::SETTINGS*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SETTINGS*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SETTINGS_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::SETTINGS*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void SETTINGScLcLset_values_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void SETTINGScLcLset_values_Dictionary();
   static void *new_SETTINGScLcLset_values(void *p = 0);
   static void *newArray_SETTINGScLcLset_values(Long_t size, void *p);
   static void delete_SETTINGScLcLset_values(void *p);
   static void deleteArray_SETTINGScLcLset_values(void *p);
   static void destruct_SETTINGScLcLset_values(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SETTINGS::set_values*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::SETTINGS::set_values) == sizeof(::ROOT::Shadow::SETTINGS::set_values));
      ::SETTINGS::set_values *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SETTINGS::set_values),0);
      static ::ROOT::TGenericClassInfo 
         instance("SETTINGS::set_values", "./../Include/organizetree.h", 185,
                  typeid(::SETTINGS::set_values), DefineBehavior(ptr, ptr),
                  &SETTINGScLcLset_values_ShowMembers, &SETTINGScLcLset_values_Dictionary, isa_proxy, 4,
                  sizeof(::SETTINGS::set_values) );
      instance.SetNew(&new_SETTINGScLcLset_values);
      instance.SetNewArray(&newArray_SETTINGScLcLset_values);
      instance.SetDelete(&delete_SETTINGScLcLset_values);
      instance.SetDeleteArray(&deleteArray_SETTINGScLcLset_values);
      instance.SetDestructor(&destruct_SETTINGScLcLset_values);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SETTINGS::set_values*)
   {
      return GenerateInitInstanceLocal((::SETTINGS::set_values*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SETTINGS::set_values*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SETTINGScLcLset_values_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::SETTINGS::set_values*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void Track_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void Track_Dictionary();
   static void *new_Track(void *p = 0);
   static void *newArray_Track(Long_t size, void *p);
   static void delete_Track(void *p);
   static void deleteArray_Track(void *p);
   static void destruct_Track(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Track*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::Track) == sizeof(::ROOT::Shadow::Track));
      ::Track *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Track),0);
      static ::ROOT::TGenericClassInfo 
         instance("Track", "./../Include/organizetree.h", 203,
                  typeid(::Track), DefineBehavior(ptr, ptr),
                  &Track_ShowMembers, &Track_Dictionary, isa_proxy, 4,
                  sizeof(::Track) );
      instance.SetNew(&new_Track);
      instance.SetNewArray(&newArray_Track);
      instance.SetDelete(&delete_Track);
      instance.SetDeleteArray(&deleteArray_Track);
      instance.SetDestructor(&destruct_Track);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Track*)
   {
      return GenerateInitInstanceLocal((::Track*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Track*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void Track_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Track*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TrackcLcLTrackEvent_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TrackcLcLTrackEvent_Dictionary();
   static void *new_TrackcLcLTrackEvent(void *p = 0);
   static void *newArray_TrackcLcLTrackEvent(Long_t size, void *p);
   static void delete_TrackcLcLTrackEvent(void *p);
   static void deleteArray_TrackcLcLTrackEvent(void *p);
   static void destruct_TrackcLcLTrackEvent(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Track::TrackEvent*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::Track::TrackEvent) == sizeof(::ROOT::Shadow::Track::TrackEvent));
      ::Track::TrackEvent *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Track::TrackEvent),0);
      static ::ROOT::TGenericClassInfo 
         instance("Track::TrackEvent", "./../Include/organizetree.h", 211,
                  typeid(::Track::TrackEvent), DefineBehavior(ptr, ptr),
                  &TrackcLcLTrackEvent_ShowMembers, &TrackcLcLTrackEvent_Dictionary, isa_proxy, 4,
                  sizeof(::Track::TrackEvent) );
      instance.SetNew(&new_TrackcLcLTrackEvent);
      instance.SetNewArray(&newArray_TrackcLcLTrackEvent);
      instance.SetDelete(&delete_TrackcLcLTrackEvent);
      instance.SetDeleteArray(&deleteArray_TrackcLcLTrackEvent);
      instance.SetDestructor(&destruct_TrackcLcLTrackEvent);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Track::TrackEvent*)
   {
      return GenerateInitInstanceLocal((::Track::TrackEvent*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Track::TrackEvent*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TrackcLcLTrackEvent_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Track::TrackEvent*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TrackcLcLSilicon_Event_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TrackcLcLSilicon_Event_Dictionary();
   static void *new_TrackcLcLSilicon_Event(void *p = 0);
   static void *newArray_TrackcLcLSilicon_Event(Long_t size, void *p);
   static void delete_TrackcLcLSilicon_Event(void *p);
   static void deleteArray_TrackcLcLSilicon_Event(void *p);
   static void destruct_TrackcLcLSilicon_Event(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Track::Silicon_Event*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::Track::Silicon_Event) == sizeof(::ROOT::Shadow::Track::Silicon_Event));
      ::Track::Silicon_Event *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Track::Silicon_Event),0);
      static ::ROOT::TGenericClassInfo 
         instance("Track::Silicon_Event", "./../Include/organizetree.h", 231,
                  typeid(::Track::Silicon_Event), DefineBehavior(ptr, ptr),
                  &TrackcLcLSilicon_Event_ShowMembers, &TrackcLcLSilicon_Event_Dictionary, isa_proxy, 4,
                  sizeof(::Track::Silicon_Event) );
      instance.SetNew(&new_TrackcLcLSilicon_Event);
      instance.SetNewArray(&newArray_TrackcLcLSilicon_Event);
      instance.SetDelete(&delete_TrackcLcLSilicon_Event);
      instance.SetDeleteArray(&deleteArray_TrackcLcLSilicon_Event);
      instance.SetDestructor(&destruct_TrackcLcLSilicon_Event);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Track::Silicon_Event*)
   {
      return GenerateInitInstanceLocal((::Track::Silicon_Event*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Track::Silicon_Event*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TrackcLcLSilicon_Event_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Track::Silicon_Event*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TrackcLcLPropCounter_Event_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void TrackcLcLPropCounter_Event_Dictionary();
   static void *new_TrackcLcLPropCounter_Event(void *p = 0);
   static void *newArray_TrackcLcLPropCounter_Event(Long_t size, void *p);
   static void delete_TrackcLcLPropCounter_Event(void *p);
   static void deleteArray_TrackcLcLPropCounter_Event(void *p);
   static void destruct_TrackcLcLPropCounter_Event(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Track::PropCounter_Event*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::Track::PropCounter_Event) == sizeof(::ROOT::Shadow::Track::PropCounter_Event));
      ::Track::PropCounter_Event *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Track::PropCounter_Event),0);
      static ::ROOT::TGenericClassInfo 
         instance("Track::PropCounter_Event", "./../Include/organizetree.h", 240,
                  typeid(::Track::PropCounter_Event), DefineBehavior(ptr, ptr),
                  &TrackcLcLPropCounter_Event_ShowMembers, &TrackcLcLPropCounter_Event_Dictionary, isa_proxy, 4,
                  sizeof(::Track::PropCounter_Event) );
      instance.SetNew(&new_TrackcLcLPropCounter_Event);
      instance.SetNewArray(&newArray_TrackcLcLPropCounter_Event);
      instance.SetDelete(&delete_TrackcLcLPropCounter_Event);
      instance.SetDeleteArray(&deleteArray_TrackcLcLPropCounter_Event);
      instance.SetDestructor(&destruct_TrackcLcLPropCounter_Event);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Track::PropCounter_Event*)
   {
      return GenerateInitInstanceLocal((::Track::PropCounter_Event*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Track::PropCounter_Event*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TrackcLcLPropCounter_Event_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Track::PropCounter_Event*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void EnergyLoss_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void EnergyLoss_Dictionary();
   static void *new_EnergyLoss(void *p = 0);
   static void *newArray_EnergyLoss(Long_t size, void *p);
   static void delete_EnergyLoss(void *p);
   static void deleteArray_EnergyLoss(void *p);
   static void destruct_EnergyLoss(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::EnergyLoss*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::EnergyLoss) == sizeof(::ROOT::Shadow::EnergyLoss));
      ::EnergyLoss *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::EnergyLoss),0);
      static ::ROOT::TGenericClassInfo 
         instance("EnergyLoss", "./../Include/EnergyLoss.h", 19,
                  typeid(::EnergyLoss), DefineBehavior(ptr, ptr),
                  &EnergyLoss_ShowMembers, &EnergyLoss_Dictionary, isa_proxy, 4,
                  sizeof(::EnergyLoss) );
      instance.SetNew(&new_EnergyLoss);
      instance.SetNewArray(&newArray_EnergyLoss);
      instance.SetDelete(&delete_EnergyLoss);
      instance.SetDeleteArray(&deleteArray_EnergyLoss);
      instance.SetDestructor(&destruct_EnergyLoss);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::EnergyLoss*)
   {
      return GenerateInitInstanceLocal((::EnergyLoss*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::EnergyLoss*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void EnergyLoss_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::EnergyLoss*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void Reconstruct_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void Reconstruct_Dictionary();
   static void *new_Reconstruct(void *p = 0);
   static void *newArray_Reconstruct(Long_t size, void *p);
   static void delete_Reconstruct(void *p);
   static void deleteArray_Reconstruct(void *p);
   static void destruct_Reconstruct(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reconstruct*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::Reconstruct) == sizeof(::ROOT::Shadow::Reconstruct));
      ::Reconstruct *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reconstruct),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reconstruct", "./../Include/Reconstruct.h", 35,
                  typeid(::Reconstruct), DefineBehavior(ptr, ptr),
                  &Reconstruct_ShowMembers, &Reconstruct_Dictionary, isa_proxy, 4,
                  sizeof(::Reconstruct) );
      instance.SetNew(&new_Reconstruct);
      instance.SetNewArray(&newArray_Reconstruct);
      instance.SetDelete(&delete_Reconstruct);
      instance.SetDeleteArray(&deleteArray_Reconstruct);
      instance.SetDestructor(&destruct_Reconstruct);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reconstruct*)
   {
      return GenerateInitInstanceLocal((::Reconstruct*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reconstruct*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void Reconstruct_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reconstruct*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReconstructcLcLBe8Event_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ReconstructcLcLBe8Event_Dictionary();
   static void *new_ReconstructcLcLBe8Event(void *p = 0);
   static void *newArray_ReconstructcLcLBe8Event(Long_t size, void *p);
   static void delete_ReconstructcLcLBe8Event(void *p);
   static void deleteArray_ReconstructcLcLBe8Event(void *p);
   static void destruct_ReconstructcLcLBe8Event(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reconstruct::Be8Event*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::Reconstruct::Be8Event) == sizeof(::ROOT::Shadow::Reconstruct::Be8Event));
      ::Reconstruct::Be8Event *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reconstruct::Be8Event),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reconstruct::Be8Event", "./../Include/Reconstruct.h", 39,
                  typeid(::Reconstruct::Be8Event), DefineBehavior(ptr, ptr),
                  &ReconstructcLcLBe8Event_ShowMembers, &ReconstructcLcLBe8Event_Dictionary, isa_proxy, 4,
                  sizeof(::Reconstruct::Be8Event) );
      instance.SetNew(&new_ReconstructcLcLBe8Event);
      instance.SetNewArray(&newArray_ReconstructcLcLBe8Event);
      instance.SetDelete(&delete_ReconstructcLcLBe8Event);
      instance.SetDeleteArray(&deleteArray_ReconstructcLcLBe8Event);
      instance.SetDestructor(&destruct_ReconstructcLcLBe8Event);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reconstruct::Be8Event*)
   {
      return GenerateInitInstanceLocal((::Reconstruct::Be8Event*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reconstruct::Be8Event*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReconstructcLcLBe8Event_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reconstruct::Be8Event*)0x0)->GetClass();
   }

} // end of namespace ROOT

//______________________________________________________________________________
namespace ROOT {
   void SiHit_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class SiHit.
      typedef ::ROOT::Shadow::SiHit ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::SiHit*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "NSiHits", &sobj->NSiHits);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "det_place_holder", (void*)&sobj->det_place_holder);
      R__insp.InspectMember("SiHit::SortByDetector", (void*)&sobj->det_place_holder, "det_place_holder.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "hit_place_holder", (void*)&sobj->hit_place_holder);
      R__insp.InspectMember("SiHit::SortByHit", (void*)&sobj->hit_place_holder, "hit_place_holder.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Detector", (void*)&sobj->Detector);
      R__insp.InspectMember("vector<SortByDetector>", (void*)&sobj->Detector, "Detector.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Hit", (void*)&sobj->Hit);
      R__insp.InspectMember("vector<SortByHit>", (void*)&sobj->Hit, "Hit.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*ReadDet", &sobj->ReadDet);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*ReadHit", &sobj->ReadHit);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_SiHit(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SiHit : new ::SiHit;
   }
   static void *newArray_SiHit(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SiHit[nElements] : new ::SiHit[nElements];
   }
   // Wrapper around operator delete
   static void delete_SiHit(void *p) {
      delete ((::SiHit*)p);
   }
   static void deleteArray_SiHit(void *p) {
      delete [] ((::SiHit*)p);
   }
   static void destruct_SiHit(void *p) {
      typedef ::SiHit current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SiHit

//______________________________________________________________________________
namespace ROOT {
   void SiHitcLcLSortByDetector_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class SiHit::SortByDetector.
      typedef ::ROOT::Shadow::SiHit::SortByDetector ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::SiHit::SortByDetector*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "DetID", &sobj->DetID);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "UpMult", &sobj->UpMult);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "DownMult", &sobj->DownMult);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "BackMult", &sobj->BackMult);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "HitType", &sobj->HitType);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "UpChNum", (void*)&sobj->UpChNum);
      R__insp.InspectMember("vector<Int_t>", (void*)&sobj->UpChNum, "UpChNum.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "DownChNum", (void*)&sobj->DownChNum);
      R__insp.InspectMember("vector<Int_t>", (void*)&sobj->DownChNum, "DownChNum.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "BackChNum", (void*)&sobj->BackChNum);
      R__insp.InspectMember("vector<Int_t>", (void*)&sobj->BackChNum, "BackChNum.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "EnergyUp_Raw", (void*)&sobj->EnergyUp_Raw);
      R__insp.InspectMember("vector<Double_t>", (void*)&sobj->EnergyUp_Raw, "EnergyUp_Raw.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "EnergyDown_Raw", (void*)&sobj->EnergyDown_Raw);
      R__insp.InspectMember("vector<Double_t>", (void*)&sobj->EnergyDown_Raw, "EnergyDown_Raw.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "EnergyBack_Raw", (void*)&sobj->EnergyBack_Raw);
      R__insp.InspectMember("vector<Double_t>", (void*)&sobj->EnergyBack_Raw, "EnergyBack_Raw.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "EnergyUp_Pulser", (void*)&sobj->EnergyUp_Pulser);
      R__insp.InspectMember("vector<Double_t>", (void*)&sobj->EnergyUp_Pulser, "EnergyUp_Pulser.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "EnergyDown_Pulser", (void*)&sobj->EnergyDown_Pulser);
      R__insp.InspectMember("vector<Double_t>", (void*)&sobj->EnergyDown_Pulser, "EnergyDown_Pulser.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "EnergyBack_Pulser", (void*)&sobj->EnergyBack_Pulser);
      R__insp.InspectMember("vector<Double_t>", (void*)&sobj->EnergyBack_Pulser, "EnergyBack_Pulser.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "EnergyUp_Rel", (void*)&sobj->EnergyUp_Rel);
      R__insp.InspectMember("vector<Double_t>", (void*)&sobj->EnergyUp_Rel, "EnergyUp_Rel.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "EnergyDown_Rel", (void*)&sobj->EnergyDown_Rel);
      R__insp.InspectMember("vector<Double_t>", (void*)&sobj->EnergyDown_Rel, "EnergyDown_Rel.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "EnergyBack_Rel", (void*)&sobj->EnergyBack_Rel);
      R__insp.InspectMember("vector<Double_t>", (void*)&sobj->EnergyBack_Rel, "EnergyBack_Rel.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "EnergyUp_Cal", (void*)&sobj->EnergyUp_Cal);
      R__insp.InspectMember("vector<Double_t>", (void*)&sobj->EnergyUp_Cal, "EnergyUp_Cal.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "EnergyDown_Cal", (void*)&sobj->EnergyDown_Cal);
      R__insp.InspectMember("vector<Double_t>", (void*)&sobj->EnergyDown_Cal, "EnergyDown_Cal.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "EnergyBack_Cal", (void*)&sobj->EnergyBack_Cal);
      R__insp.InspectMember("vector<Double_t>", (void*)&sobj->EnergyBack_Cal, "EnergyBack_Cal.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "TimeUp", (void*)&sobj->TimeUp);
      R__insp.InspectMember("vector<Double_t>", (void*)&sobj->TimeUp, "TimeUp.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "TimeDown", (void*)&sobj->TimeDown);
      R__insp.InspectMember("vector<Double_t>", (void*)&sobj->TimeDown, "TimeDown.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "TimeBack", (void*)&sobj->TimeBack);
      R__insp.InspectMember("vector<Double_t>", (void*)&sobj->TimeBack, "TimeBack.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_SiHitcLcLSortByDetector(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SiHit::SortByDetector : new ::SiHit::SortByDetector;
   }
   static void *newArray_SiHitcLcLSortByDetector(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SiHit::SortByDetector[nElements] : new ::SiHit::SortByDetector[nElements];
   }
   // Wrapper around operator delete
   static void delete_SiHitcLcLSortByDetector(void *p) {
      delete ((::SiHit::SortByDetector*)p);
   }
   static void deleteArray_SiHitcLcLSortByDetector(void *p) {
      delete [] ((::SiHit::SortByDetector*)p);
   }
   static void destruct_SiHitcLcLSortByDetector(void *p) {
      typedef ::SiHit::SortByDetector current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SiHit::SortByDetector

//______________________________________________________________________________
namespace ROOT {
   void SiHitcLcLSortByHit_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class SiHit::SortByHit.
      typedef ::ROOT::Shadow::SiHit::SortByHit ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::SiHit::SortByHit*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "NHitsInDet", &sobj->NHitsInDet);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "DetID", &sobj->DetID);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Flag", &sobj->Flag);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "HitType", &sobj->HitType);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "FrontChannel", &sobj->FrontChannel);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "BackChannel", &sobj->BackChannel);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "EnergyBack", &sobj->EnergyBack);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "EnergyFront", &sobj->EnergyFront);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Energy", &sobj->Energy);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Time", &sobj->Time);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "X", &sobj->X);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Y", &sobj->Y);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Z", &sobj->Z);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "XW", &sobj->XW);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "YW", &sobj->YW);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ZW", &sobj->ZW);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "RW", &sobj->RW);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PhiW", &sobj->PhiW);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "RFSubtract", &sobj->RFSubtract);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "TrackType", &sobj->TrackType);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_SiHitcLcLSortByHit(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SiHit::SortByHit : new ::SiHit::SortByHit;
   }
   static void *newArray_SiHitcLcLSortByHit(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SiHit::SortByHit[nElements] : new ::SiHit::SortByHit[nElements];
   }
   // Wrapper around operator delete
   static void delete_SiHitcLcLSortByHit(void *p) {
      delete ((::SiHit::SortByHit*)p);
   }
   static void deleteArray_SiHitcLcLSortByHit(void *p) {
      delete [] ((::SiHit::SortByHit*)p);
   }
   static void destruct_SiHitcLcLSortByHit(void *p) {
      typedef ::SiHit::SortByHit current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SiHit::SortByHit

//______________________________________________________________________________
namespace ROOT {
   void PCHit_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class PCHit.
      typedef ::ROOT::Shadow::PCHit ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::PCHit*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "NPCHits", &sobj->NPCHits);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "pc_place_holder", (void*)&sobj->pc_place_holder);
      R__insp.InspectMember("PCHit::SortByPC", (void*)&sobj->pc_place_holder, "pc_place_holder.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Hit", (void*)&sobj->Hit);
      R__insp.InspectMember("vector<SortByPC>", (void*)&sobj->Hit, "Hit.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*ReadHit", &sobj->ReadHit);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_PCHit(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PCHit : new ::PCHit;
   }
   static void *newArray_PCHit(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PCHit[nElements] : new ::PCHit[nElements];
   }
   // Wrapper around operator delete
   static void delete_PCHit(void *p) {
      delete ((::PCHit*)p);
   }
   static void deleteArray_PCHit(void *p) {
      delete [] ((::PCHit*)p);
   }
   static void destruct_PCHit(void *p) {
      typedef ::PCHit current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PCHit

//______________________________________________________________________________
namespace ROOT {
   void PCHitcLcLSortByPC_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class PCHit::SortByPC.
      typedef ::ROOT::Shadow::PCHit::SortByPC ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::PCHit::SortByPC*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "WireID", &sobj->WireID);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Down", &sobj->Down);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Up", &sobj->Up);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "DownVoltage", &sobj->DownVoltage);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "UpVoltage", &sobj->UpVoltage);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Energy", &sobj->Energy);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Z", &sobj->Z);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "XW", &sobj->XW);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "YW", &sobj->YW);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ZW", &sobj->ZW);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "RW", &sobj->RW);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PhiW", &sobj->PhiW);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "TrackType", &sobj->TrackType);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_PCHitcLcLSortByPC(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PCHit::SortByPC : new ::PCHit::SortByPC;
   }
   static void *newArray_PCHitcLcLSortByPC(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PCHit::SortByPC[nElements] : new ::PCHit::SortByPC[nElements];
   }
   // Wrapper around operator delete
   static void delete_PCHitcLcLSortByPC(void *p) {
      delete ((::PCHit::SortByPC*)p);
   }
   static void deleteArray_PCHitcLcLSortByPC(void *p) {
      delete [] ((::PCHit::SortByPC*)p);
   }
   static void destruct_PCHitcLcLSortByPC(void *p) {
      typedef ::PCHit::SortByPC current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PCHit::SortByPC

//______________________________________________________________________________
namespace ROOT {
   void SETTINGS_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class SETTINGS.
      typedef ::ROOT::Shadow::SETTINGS ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::SETTINGS*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "set_val", (void*)&sobj->set_val);
      R__insp.InspectMember("SETTINGS::set_values", (void*)&sobj->set_val, "set_val.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_SETTINGS(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SETTINGS : new ::SETTINGS;
   }
   static void *newArray_SETTINGS(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SETTINGS[nElements] : new ::SETTINGS[nElements];
   }
   // Wrapper around operator delete
   static void delete_SETTINGS(void *p) {
      delete ((::SETTINGS*)p);
   }
   static void deleteArray_SETTINGS(void *p) {
      delete [] ((::SETTINGS*)p);
   }
   static void destruct_SETTINGS(void *p) {
      typedef ::SETTINGS current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SETTINGS

//______________________________________________________________________________
namespace ROOT {
   void SETTINGScLcLset_values_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class SETTINGS::set_values.
      typedef ::ROOT::Shadow::SETTINGS::set_values ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::SETTINGS::set_values*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "X3Pulser_Offset[24][12]", sobj->X3Pulser_Offset);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "X3Pulser_Slope[24][12]", sobj->X3Pulser_Slope);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "X3RelativeGains[24][12]", sobj->X3RelativeGains);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "X3FinalFix[24][12]", sobj->X3FinalFix);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "X3Geometry_Up[24][4][4]", sobj->X3Geometry_Up);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "X3Geometry_Down[24][4][4]", sobj->X3Geometry_Down);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "QQQPulser_Offset[4][32]", sobj->QQQPulser_Offset);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "QQQPulser_Slope[4][32]", sobj->QQQPulser_Slope);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "QQQRelativeGains[4][32]", sobj->QQQRelativeGains);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "QQQFinalFix[4][32]", sobj->QQQFinalFix);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "SiAlphaCal[28]", sobj->SiAlphaCal);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_SETTINGScLcLset_values(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SETTINGS::set_values : new ::SETTINGS::set_values;
   }
   static void *newArray_SETTINGScLcLset_values(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SETTINGS::set_values[nElements] : new ::SETTINGS::set_values[nElements];
   }
   // Wrapper around operator delete
   static void delete_SETTINGScLcLset_values(void *p) {
      delete ((::SETTINGS::set_values*)p);
   }
   static void deleteArray_SETTINGScLcLset_values(void *p) {
      delete [] ((::SETTINGS::set_values*)p);
   }
   static void destruct_SETTINGScLcLset_values(void *p) {
      typedef ::SETTINGS::set_values current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SETTINGS::set_values

//______________________________________________________________________________
namespace ROOT {
   void Track_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class Track.
      typedef ::ROOT::Shadow::Track ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::Track*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "NTracks", &sobj->NTracks);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "NTracks1", &sobj->NTracks1);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "NTracks2", &sobj->NTracks2);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "NTracks3", &sobj->NTracks3);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "track_place_holder", (void*)&sobj->track_place_holder);
      R__insp.InspectMember("Track::TrackEvent", (void*)&sobj->track_place_holder, "track_place_holder.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "si_place_holder", (void*)&sobj->si_place_holder);
      R__insp.InspectMember("Track::Silicon_Event", (void*)&sobj->si_place_holder, "si_place_holder.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "pc_place_holder", (void*)&sobj->pc_place_holder);
      R__insp.InspectMember("Track::PropCounter_Event", (void*)&sobj->pc_place_holder, "pc_place_holder.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "TrEvent", (void*)&sobj->TrEvent);
      R__insp.InspectMember("vector<TrackEvent>", (void*)&sobj->TrEvent, "TrEvent.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*ReadTrEvent", &sobj->ReadTrEvent);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "SiEvent", (void*)&sobj->SiEvent);
      R__insp.InspectMember("vector<Silicon_Event>", (void*)&sobj->SiEvent, "SiEvent.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*ReadSiEvent", &sobj->ReadSiEvent);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PCEvent", (void*)&sobj->PCEvent);
      R__insp.InspectMember("vector<PropCounter_Event>", (void*)&sobj->PCEvent, "PCEvent.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*ReadPCEvent", &sobj->ReadPCEvent);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_Track(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Track : new ::Track;
   }
   static void *newArray_Track(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Track[nElements] : new ::Track[nElements];
   }
   // Wrapper around operator delete
   static void delete_Track(void *p) {
      delete ((::Track*)p);
   }
   static void deleteArray_Track(void *p) {
      delete [] ((::Track*)p);
   }
   static void destruct_Track(void *p) {
      typedef ::Track current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Track

//______________________________________________________________________________
namespace ROOT {
   void TrackcLcLTrackEvent_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class Track::TrackEvent.
      typedef ::ROOT::Shadow::Track::TrackEvent ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::Track::TrackEvent*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "TrackType", &sobj->TrackType);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "DetID", &sobj->DetID);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "WireID", &sobj->WireID);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "SiEnergy", &sobj->SiEnergy);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "SiZ", &sobj->SiZ);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "SiR", &sobj->SiR);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "SiPhi", &sobj->SiPhi);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PCEnergy", &sobj->PCEnergy);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PCZ", &sobj->PCZ);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PCR", &sobj->PCR);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PCPhi", &sobj->PCPhi);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "IntPoint", &sobj->IntPoint);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PathLength", &sobj->PathLength);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Theta", &sobj->Theta);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Phi", &sobj->Phi);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "BeamEnergy", &sobj->BeamEnergy);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PCZ_Ref", &sobj->PCZ_Ref);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TrackcLcLTrackEvent(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Track::TrackEvent : new ::Track::TrackEvent;
   }
   static void *newArray_TrackcLcLTrackEvent(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Track::TrackEvent[nElements] : new ::Track::TrackEvent[nElements];
   }
   // Wrapper around operator delete
   static void delete_TrackcLcLTrackEvent(void *p) {
      delete ((::Track::TrackEvent*)p);
   }
   static void deleteArray_TrackcLcLTrackEvent(void *p) {
      delete [] ((::Track::TrackEvent*)p);
   }
   static void destruct_TrackcLcLTrackEvent(void *p) {
      typedef ::Track::TrackEvent current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Track::TrackEvent

//______________________________________________________________________________
namespace ROOT {
   void TrackcLcLSilicon_Event_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class Track::Silicon_Event.
      typedef ::ROOT::Shadow::Track::Silicon_Event ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::Track::Silicon_Event*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "TrackType", &sobj->TrackType);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "DetID", &sobj->DetID);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "SiEnergy", &sobj->SiEnergy);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "SiZ", &sobj->SiZ);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "SiR", &sobj->SiR);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "SiPhi", &sobj->SiPhi);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TrackcLcLSilicon_Event(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Track::Silicon_Event : new ::Track::Silicon_Event;
   }
   static void *newArray_TrackcLcLSilicon_Event(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Track::Silicon_Event[nElements] : new ::Track::Silicon_Event[nElements];
   }
   // Wrapper around operator delete
   static void delete_TrackcLcLSilicon_Event(void *p) {
      delete ((::Track::Silicon_Event*)p);
   }
   static void deleteArray_TrackcLcLSilicon_Event(void *p) {
      delete [] ((::Track::Silicon_Event*)p);
   }
   static void destruct_TrackcLcLSilicon_Event(void *p) {
      typedef ::Track::Silicon_Event current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Track::Silicon_Event

//______________________________________________________________________________
namespace ROOT {
   void TrackcLcLPropCounter_Event_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class Track::PropCounter_Event.
      typedef ::ROOT::Shadow::Track::PropCounter_Event ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::Track::PropCounter_Event*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "TrackType", &sobj->TrackType);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "WireID", &sobj->WireID);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PCEnergy", &sobj->PCEnergy);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PCZ", &sobj->PCZ);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PCR", &sobj->PCR);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PCPhi", &sobj->PCPhi);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TrackcLcLPropCounter_Event(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Track::PropCounter_Event : new ::Track::PropCounter_Event;
   }
   static void *newArray_TrackcLcLPropCounter_Event(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Track::PropCounter_Event[nElements] : new ::Track::PropCounter_Event[nElements];
   }
   // Wrapper around operator delete
   static void delete_TrackcLcLPropCounter_Event(void *p) {
      delete ((::Track::PropCounter_Event*)p);
   }
   static void deleteArray_TrackcLcLPropCounter_Event(void *p) {
      delete [] ((::Track::PropCounter_Event*)p);
   }
   static void destruct_TrackcLcLPropCounter_Event(void *p) {
      typedef ::Track::PropCounter_Event current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Track::PropCounter_Event

//______________________________________________________________________________
namespace ROOT {
   void EnergyLoss_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class EnergyLoss.
      typedef ::ROOT::Shadow::EnergyLoss ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::EnergyLoss*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "GoodELossFile", &sobj->GoodELossFile);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*EvD", &sobj->EvD);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "c", &sobj->c);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*IonEnergy", &sobj->IonEnergy);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "IonMass", &sobj->IonMass);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*dEdx_e", &sobj->dEdx_e);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*dEdx_n", &sobj->dEdx_n);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "points", &sobj->points);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "last_point", &sobj->last_point);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Energy_in_range", &sobj->Energy_in_range);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_EnergyLoss(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::EnergyLoss : new ::EnergyLoss;
   }
   static void *newArray_EnergyLoss(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::EnergyLoss[nElements] : new ::EnergyLoss[nElements];
   }
   // Wrapper around operator delete
   static void delete_EnergyLoss(void *p) {
      delete ((::EnergyLoss*)p);
   }
   static void deleteArray_EnergyLoss(void *p) {
      delete [] ((::EnergyLoss*)p);
   }
   static void destruct_EnergyLoss(void *p) {
      typedef ::EnergyLoss current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::EnergyLoss

//______________________________________________________________________________
namespace ROOT {
   void Reconstruct_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class Reconstruct.
      typedef ::ROOT::Shadow::Reconstruct ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::Reconstruct*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "BeEvent", (void*)&sobj->BeEvent);
      R__insp.InspectMember("Reconstruct::Be8Event", (void*)&sobj->BeEvent, "BeEvent.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_Reconstruct(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reconstruct : new ::Reconstruct;
   }
   static void *newArray_Reconstruct(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reconstruct[nElements] : new ::Reconstruct[nElements];
   }
   // Wrapper around operator delete
   static void delete_Reconstruct(void *p) {
      delete ((::Reconstruct*)p);
   }
   static void deleteArray_Reconstruct(void *p) {
      delete [] ((::Reconstruct*)p);
   }
   static void destruct_Reconstruct(void *p) {
      typedef ::Reconstruct current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reconstruct

//______________________________________________________________________________
namespace ROOT {
   void ReconstructcLcLBe8Event_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class Reconstruct::Be8Event.
      typedef ::ROOT::Shadow::Reconstruct::Be8Event ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::Reconstruct::Be8Event*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "DiffIntPoint", &sobj->DiffIntPoint);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "SiEnergy_tot", &sobj->SiEnergy_tot);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PCEnergy_tot", &sobj->PCEnergy_tot);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Energy_tot", &sobj->Energy_tot);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "AlphaAngle", &sobj->AlphaAngle);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "BeTheta", &sobj->BeTheta);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "BePhi", &sobj->BePhi);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "BeKE", &sobj->BeKE);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Ex", &sobj->Ex);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "AvgBeamEnergy", &sobj->AvgBeamEnergy);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReconstructcLcLBe8Event(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reconstruct::Be8Event : new ::Reconstruct::Be8Event;
   }
   static void *newArray_ReconstructcLcLBe8Event(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reconstruct::Be8Event[nElements] : new ::Reconstruct::Be8Event[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReconstructcLcLBe8Event(void *p) {
      delete ((::Reconstruct::Be8Event*)p);
   }
   static void deleteArray_ReconstructcLcLBe8Event(void *p) {
      delete [] ((::Reconstruct::Be8Event*)p);
   }
   static void destruct_ReconstructcLcLBe8Event(void *p) {
      typedef ::Reconstruct::Be8Event current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reconstruct::Be8Event

namespace ROOT {
   void vectorlEPCHitcLcLSortByPCgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEPCHitcLcLSortByPCgR_Dictionary();
   static void *new_vectorlEPCHitcLcLSortByPCgR(void *p = 0);
   static void *newArray_vectorlEPCHitcLcLSortByPCgR(Long_t size, void *p);
   static void delete_vectorlEPCHitcLcLSortByPCgR(void *p);
   static void deleteArray_vectorlEPCHitcLcLSortByPCgR(void *p);
   static void destruct_vectorlEPCHitcLcLSortByPCgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<PCHit::SortByPC>*)
   {
      vector<PCHit::SortByPC> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<PCHit::SortByPC>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<PCHit::SortByPC>", -2, "prec_stl/vector", 49,
                  typeid(vector<PCHit::SortByPC>), DefineBehavior(ptr, ptr),
                  0, &vectorlEPCHitcLcLSortByPCgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<PCHit::SortByPC>) );
      instance.SetNew(&new_vectorlEPCHitcLcLSortByPCgR);
      instance.SetNewArray(&newArray_vectorlEPCHitcLcLSortByPCgR);
      instance.SetDelete(&delete_vectorlEPCHitcLcLSortByPCgR);
      instance.SetDeleteArray(&deleteArray_vectorlEPCHitcLcLSortByPCgR);
      instance.SetDestructor(&destruct_vectorlEPCHitcLcLSortByPCgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<PCHit::SortByPC> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<PCHit::SortByPC>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEPCHitcLcLSortByPCgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<PCHit::SortByPC>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEPCHitcLcLSortByPCgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<PCHit::SortByPC> : new vector<PCHit::SortByPC>;
   }
   static void *newArray_vectorlEPCHitcLcLSortByPCgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<PCHit::SortByPC>[nElements] : new vector<PCHit::SortByPC>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEPCHitcLcLSortByPCgR(void *p) {
      delete ((vector<PCHit::SortByPC>*)p);
   }
   static void deleteArray_vectorlEPCHitcLcLSortByPCgR(void *p) {
      delete [] ((vector<PCHit::SortByPC>*)p);
   }
   static void destruct_vectorlEPCHitcLcLSortByPCgR(void *p) {
      typedef vector<PCHit::SortByPC> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<PCHit::SortByPC>

namespace ROOT {
   void vectorlESiHitcLcLSortByDetectorgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlESiHitcLcLSortByDetectorgR_Dictionary();
   static void *new_vectorlESiHitcLcLSortByDetectorgR(void *p = 0);
   static void *newArray_vectorlESiHitcLcLSortByDetectorgR(Long_t size, void *p);
   static void delete_vectorlESiHitcLcLSortByDetectorgR(void *p);
   static void deleteArray_vectorlESiHitcLcLSortByDetectorgR(void *p);
   static void destruct_vectorlESiHitcLcLSortByDetectorgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<SiHit::SortByDetector>*)
   {
      vector<SiHit::SortByDetector> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<SiHit::SortByDetector>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<SiHit::SortByDetector>", -2, "prec_stl/vector", 49,
                  typeid(vector<SiHit::SortByDetector>), DefineBehavior(ptr, ptr),
                  0, &vectorlESiHitcLcLSortByDetectorgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<SiHit::SortByDetector>) );
      instance.SetNew(&new_vectorlESiHitcLcLSortByDetectorgR);
      instance.SetNewArray(&newArray_vectorlESiHitcLcLSortByDetectorgR);
      instance.SetDelete(&delete_vectorlESiHitcLcLSortByDetectorgR);
      instance.SetDeleteArray(&deleteArray_vectorlESiHitcLcLSortByDetectorgR);
      instance.SetDestructor(&destruct_vectorlESiHitcLcLSortByDetectorgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<SiHit::SortByDetector> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<SiHit::SortByDetector>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlESiHitcLcLSortByDetectorgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<SiHit::SortByDetector>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlESiHitcLcLSortByDetectorgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<SiHit::SortByDetector> : new vector<SiHit::SortByDetector>;
   }
   static void *newArray_vectorlESiHitcLcLSortByDetectorgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<SiHit::SortByDetector>[nElements] : new vector<SiHit::SortByDetector>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlESiHitcLcLSortByDetectorgR(void *p) {
      delete ((vector<SiHit::SortByDetector>*)p);
   }
   static void deleteArray_vectorlESiHitcLcLSortByDetectorgR(void *p) {
      delete [] ((vector<SiHit::SortByDetector>*)p);
   }
   static void destruct_vectorlESiHitcLcLSortByDetectorgR(void *p) {
      typedef vector<SiHit::SortByDetector> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<SiHit::SortByDetector>

namespace ROOT {
   void vectorlESiHitcLcLSortByHitgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlESiHitcLcLSortByHitgR_Dictionary();
   static void *new_vectorlESiHitcLcLSortByHitgR(void *p = 0);
   static void *newArray_vectorlESiHitcLcLSortByHitgR(Long_t size, void *p);
   static void delete_vectorlESiHitcLcLSortByHitgR(void *p);
   static void deleteArray_vectorlESiHitcLcLSortByHitgR(void *p);
   static void destruct_vectorlESiHitcLcLSortByHitgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<SiHit::SortByHit>*)
   {
      vector<SiHit::SortByHit> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<SiHit::SortByHit>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<SiHit::SortByHit>", -2, "prec_stl/vector", 49,
                  typeid(vector<SiHit::SortByHit>), DefineBehavior(ptr, ptr),
                  0, &vectorlESiHitcLcLSortByHitgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<SiHit::SortByHit>) );
      instance.SetNew(&new_vectorlESiHitcLcLSortByHitgR);
      instance.SetNewArray(&newArray_vectorlESiHitcLcLSortByHitgR);
      instance.SetDelete(&delete_vectorlESiHitcLcLSortByHitgR);
      instance.SetDeleteArray(&deleteArray_vectorlESiHitcLcLSortByHitgR);
      instance.SetDestructor(&destruct_vectorlESiHitcLcLSortByHitgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<SiHit::SortByHit> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<SiHit::SortByHit>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlESiHitcLcLSortByHitgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<SiHit::SortByHit>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlESiHitcLcLSortByHitgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<SiHit::SortByHit> : new vector<SiHit::SortByHit>;
   }
   static void *newArray_vectorlESiHitcLcLSortByHitgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<SiHit::SortByHit>[nElements] : new vector<SiHit::SortByHit>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlESiHitcLcLSortByHitgR(void *p) {
      delete ((vector<SiHit::SortByHit>*)p);
   }
   static void deleteArray_vectorlESiHitcLcLSortByHitgR(void *p) {
      delete [] ((vector<SiHit::SortByHit>*)p);
   }
   static void destruct_vectorlESiHitcLcLSortByHitgR(void *p) {
      typedef vector<SiHit::SortByHit> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<SiHit::SortByHit>

namespace ROOT {
   void vectorlETrackcLcLPropCounter_EventgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlETrackcLcLPropCounter_EventgR_Dictionary();
   static void *new_vectorlETrackcLcLPropCounter_EventgR(void *p = 0);
   static void *newArray_vectorlETrackcLcLPropCounter_EventgR(Long_t size, void *p);
   static void delete_vectorlETrackcLcLPropCounter_EventgR(void *p);
   static void deleteArray_vectorlETrackcLcLPropCounter_EventgR(void *p);
   static void destruct_vectorlETrackcLcLPropCounter_EventgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<Track::PropCounter_Event>*)
   {
      vector<Track::PropCounter_Event> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<Track::PropCounter_Event>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<Track::PropCounter_Event>", -2, "prec_stl/vector", 49,
                  typeid(vector<Track::PropCounter_Event>), DefineBehavior(ptr, ptr),
                  0, &vectorlETrackcLcLPropCounter_EventgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<Track::PropCounter_Event>) );
      instance.SetNew(&new_vectorlETrackcLcLPropCounter_EventgR);
      instance.SetNewArray(&newArray_vectorlETrackcLcLPropCounter_EventgR);
      instance.SetDelete(&delete_vectorlETrackcLcLPropCounter_EventgR);
      instance.SetDeleteArray(&deleteArray_vectorlETrackcLcLPropCounter_EventgR);
      instance.SetDestructor(&destruct_vectorlETrackcLcLPropCounter_EventgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<Track::PropCounter_Event> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<Track::PropCounter_Event>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETrackcLcLPropCounter_EventgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<Track::PropCounter_Event>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETrackcLcLPropCounter_EventgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Track::PropCounter_Event> : new vector<Track::PropCounter_Event>;
   }
   static void *newArray_vectorlETrackcLcLPropCounter_EventgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Track::PropCounter_Event>[nElements] : new vector<Track::PropCounter_Event>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETrackcLcLPropCounter_EventgR(void *p) {
      delete ((vector<Track::PropCounter_Event>*)p);
   }
   static void deleteArray_vectorlETrackcLcLPropCounter_EventgR(void *p) {
      delete [] ((vector<Track::PropCounter_Event>*)p);
   }
   static void destruct_vectorlETrackcLcLPropCounter_EventgR(void *p) {
      typedef vector<Track::PropCounter_Event> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<Track::PropCounter_Event>

namespace ROOT {
   void vectorlETrackcLcLSilicon_EventgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlETrackcLcLSilicon_EventgR_Dictionary();
   static void *new_vectorlETrackcLcLSilicon_EventgR(void *p = 0);
   static void *newArray_vectorlETrackcLcLSilicon_EventgR(Long_t size, void *p);
   static void delete_vectorlETrackcLcLSilicon_EventgR(void *p);
   static void deleteArray_vectorlETrackcLcLSilicon_EventgR(void *p);
   static void destruct_vectorlETrackcLcLSilicon_EventgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<Track::Silicon_Event>*)
   {
      vector<Track::Silicon_Event> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<Track::Silicon_Event>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<Track::Silicon_Event>", -2, "prec_stl/vector", 49,
                  typeid(vector<Track::Silicon_Event>), DefineBehavior(ptr, ptr),
                  0, &vectorlETrackcLcLSilicon_EventgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<Track::Silicon_Event>) );
      instance.SetNew(&new_vectorlETrackcLcLSilicon_EventgR);
      instance.SetNewArray(&newArray_vectorlETrackcLcLSilicon_EventgR);
      instance.SetDelete(&delete_vectorlETrackcLcLSilicon_EventgR);
      instance.SetDeleteArray(&deleteArray_vectorlETrackcLcLSilicon_EventgR);
      instance.SetDestructor(&destruct_vectorlETrackcLcLSilicon_EventgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<Track::Silicon_Event> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<Track::Silicon_Event>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETrackcLcLSilicon_EventgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<Track::Silicon_Event>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETrackcLcLSilicon_EventgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Track::Silicon_Event> : new vector<Track::Silicon_Event>;
   }
   static void *newArray_vectorlETrackcLcLSilicon_EventgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Track::Silicon_Event>[nElements] : new vector<Track::Silicon_Event>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETrackcLcLSilicon_EventgR(void *p) {
      delete ((vector<Track::Silicon_Event>*)p);
   }
   static void deleteArray_vectorlETrackcLcLSilicon_EventgR(void *p) {
      delete [] ((vector<Track::Silicon_Event>*)p);
   }
   static void destruct_vectorlETrackcLcLSilicon_EventgR(void *p) {
      typedef vector<Track::Silicon_Event> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<Track::Silicon_Event>

namespace ROOT {
   void vectorlETrackcLcLTrackEventgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlETrackcLcLTrackEventgR_Dictionary();
   static void *new_vectorlETrackcLcLTrackEventgR(void *p = 0);
   static void *newArray_vectorlETrackcLcLTrackEventgR(Long_t size, void *p);
   static void delete_vectorlETrackcLcLTrackEventgR(void *p);
   static void deleteArray_vectorlETrackcLcLTrackEventgR(void *p);
   static void destruct_vectorlETrackcLcLTrackEventgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<Track::TrackEvent>*)
   {
      vector<Track::TrackEvent> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<Track::TrackEvent>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<Track::TrackEvent>", -2, "prec_stl/vector", 49,
                  typeid(vector<Track::TrackEvent>), DefineBehavior(ptr, ptr),
                  0, &vectorlETrackcLcLTrackEventgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<Track::TrackEvent>) );
      instance.SetNew(&new_vectorlETrackcLcLTrackEventgR);
      instance.SetNewArray(&newArray_vectorlETrackcLcLTrackEventgR);
      instance.SetDelete(&delete_vectorlETrackcLcLTrackEventgR);
      instance.SetDeleteArray(&deleteArray_vectorlETrackcLcLTrackEventgR);
      instance.SetDestructor(&destruct_vectorlETrackcLcLTrackEventgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<Track::TrackEvent> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<Track::TrackEvent>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETrackcLcLTrackEventgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<Track::TrackEvent>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETrackcLcLTrackEventgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Track::TrackEvent> : new vector<Track::TrackEvent>;
   }
   static void *newArray_vectorlETrackcLcLTrackEventgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Track::TrackEvent>[nElements] : new vector<Track::TrackEvent>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETrackcLcLTrackEventgR(void *p) {
      delete ((vector<Track::TrackEvent>*)p);
   }
   static void deleteArray_vectorlETrackcLcLTrackEventgR(void *p) {
      delete [] ((vector<Track::TrackEvent>*)p);
   }
   static void destruct_vectorlETrackcLcLTrackEventgR(void *p) {
      typedef vector<Track::TrackEvent> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<Track::TrackEvent>

namespace ROOT {
   void vectorlEdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEdoublegR_Dictionary();
   static void *new_vectorlEdoublegR(void *p = 0);
   static void *newArray_vectorlEdoublegR(Long_t size, void *p);
   static void delete_vectorlEdoublegR(void *p);
   static void deleteArray_vectorlEdoublegR(void *p);
   static void destruct_vectorlEdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<double>*)
   {
      vector<double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<double>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<double>", -2, "vector.dll", 0,
                  typeid(vector<double>), DefineBehavior(ptr, ptr),
                  0, &vectorlEdoublegR_Dictionary, isa_proxy, 0,
                  sizeof(vector<double>) );
      instance.SetNew(&new_vectorlEdoublegR);
      instance.SetNewArray(&newArray_vectorlEdoublegR);
      instance.SetDelete(&delete_vectorlEdoublegR);
      instance.SetDeleteArray(&deleteArray_vectorlEdoublegR);
      instance.SetDestructor(&destruct_vectorlEdoublegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<double> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEdoublegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<double> : new vector<double>;
   }
   static void *newArray_vectorlEdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<double>[nElements] : new vector<double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEdoublegR(void *p) {
      delete ((vector<double>*)p);
   }
   static void deleteArray_vectorlEdoublegR(void *p) {
      delete [] ((vector<double>*)p);
   }
   static void destruct_vectorlEdoublegR(void *p) {
      typedef vector<double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<double>

namespace ROOT {
   void vectorlEintgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEintgR_Dictionary();
   static void *new_vectorlEintgR(void *p = 0);
   static void *newArray_vectorlEintgR(Long_t size, void *p);
   static void delete_vectorlEintgR(void *p);
   static void deleteArray_vectorlEintgR(void *p);
   static void destruct_vectorlEintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<int>*)
   {
      vector<int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<int>", -2, "prec_stl/vector", 49,
                  typeid(vector<int>), DefineBehavior(ptr, ptr),
                  0, &vectorlEintgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<int>) );
      instance.SetNew(&new_vectorlEintgR);
      instance.SetNewArray(&newArray_vectorlEintgR);
      instance.SetDelete(&delete_vectorlEintgR);
      instance.SetDeleteArray(&deleteArray_vectorlEintgR);
      instance.SetDestructor(&destruct_vectorlEintgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<int> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEintgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<int>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<int> : new vector<int>;
   }
   static void *newArray_vectorlEintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<int>[nElements] : new vector<int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEintgR(void *p) {
      delete ((vector<int>*)p);
   }
   static void deleteArray_vectorlEintgR(void *p) {
      delete [] ((vector<int>*)p);
   }
   static void destruct_vectorlEintgR(void *p) {
      typedef vector<int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<int>

/********************************************************
* Reconstruct.cxx
* CAUTION: DON'T CHANGE THIS FILE. THIS FILE IS AUTOMATICALLY GENERATED
*          FROM HEADER FILES LISTED IN G__setup_cpp_environmentXXX().
*          CHANGE THOSE HEADER FILES AND REGENERATE THIS FILE.
********************************************************/

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

#if defined(__GNUC__) && __GNUC__ >= 4 && ((__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ >= 1) || (__GNUC_MINOR__ >= 3))
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif

extern "C" void G__cpp_reset_tagtableReconstruct();

extern "C" void G__set_cpp_environmentReconstruct() {
  G__add_compiledheader("TObject.h");
  G__add_compiledheader("TMemberInspector.h");
  G__add_compiledheader("../Include/organizetree.h");
  G__add_compiledheader("../Include/EnergyLoss.h");
  G__add_compiledheader("../Include/Reconstruct.h");
  G__cpp_reset_tagtableReconstruct();
}
#include <new>
extern "C" int G__cpp_dllrevReconstruct() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* SiHit */
static int G__Reconstruct_215_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SiHit* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SiHit[n];
     } else {
       p = new((void*) gvp) SiHit[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SiHit;
     } else {
       p = new((void*) gvp) SiHit;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_SiHit));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Reconstruct_215_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((SiHit*) G__getstructoffset())->zeroPlaceHolder();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Reconstruct_215_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((SiHit*) G__getstructoffset())->zeroSiHit();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Reconstruct_215_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SiHit* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SiHit(*(SiHit*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_SiHit));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SiHit G__TSiHit;
static int G__Reconstruct_215_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SiHit*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SiHit*) (soff+(sizeof(SiHit)*i)))->~G__TSiHit();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SiHit*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SiHit*) (soff))->~G__TSiHit();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Reconstruct_215_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SiHit* dest = (SiHit*) G__getstructoffset();
   *dest = *(SiHit*) libp->para[0].ref;
   const SiHit& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SiHit::SortByDetector */
// automatic default constructor
static int G__Reconstruct_216_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SiHit::SortByDetector *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SiHit::SortByDetector[n];
     } else {
       p = new((void*) gvp) SiHit::SortByDetector[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SiHit::SortByDetector;
     } else {
       p = new((void*) gvp) SiHit::SortByDetector;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_SiHitcLcLSortByDetector));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Reconstruct_216_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SiHit::SortByDetector* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SiHit::SortByDetector(*(SiHit::SortByDetector*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_SiHitcLcLSortByDetector));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SiHit::SortByDetector G__TSiHitcLcLSortByDetector;
static int G__Reconstruct_216_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SiHit::SortByDetector*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SiHit::SortByDetector*) (soff+(sizeof(SiHit::SortByDetector)*i)))->~G__TSiHitcLcLSortByDetector();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SiHit::SortByDetector*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SiHit::SortByDetector*) (soff))->~G__TSiHitcLcLSortByDetector();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Reconstruct_216_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SiHit::SortByDetector* dest = (SiHit::SortByDetector*) G__getstructoffset();
   *dest = *(SiHit::SortByDetector*) libp->para[0].ref;
   const SiHit::SortByDetector& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SiHit::SortByHit */
// automatic default constructor
static int G__Reconstruct_221_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SiHit::SortByHit *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SiHit::SortByHit[n];
     } else {
       p = new((void*) gvp) SiHit::SortByHit[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SiHit::SortByHit;
     } else {
       p = new((void*) gvp) SiHit::SortByHit;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_SiHitcLcLSortByHit));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Reconstruct_221_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SiHit::SortByHit* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SiHit::SortByHit(*(SiHit::SortByHit*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_SiHitcLcLSortByHit));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SiHit::SortByHit G__TSiHitcLcLSortByHit;
static int G__Reconstruct_221_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SiHit::SortByHit*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SiHit::SortByHit*) (soff+(sizeof(SiHit::SortByHit)*i)))->~G__TSiHitcLcLSortByHit();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SiHit::SortByHit*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SiHit::SortByHit*) (soff))->~G__TSiHitcLcLSortByHit();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Reconstruct_221_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SiHit::SortByHit* dest = (SiHit::SortByHit*) G__getstructoffset();
   *dest = *(SiHit::SortByHit*) libp->para[0].ref;
   const SiHit::SortByHit& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* PCHit */
static int G__Reconstruct_230_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PCHit* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PCHit[n];
     } else {
       p = new((void*) gvp) PCHit[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PCHit;
     } else {
       p = new((void*) gvp) PCHit;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_PCHit));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Reconstruct_230_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((PCHit*) G__getstructoffset())->zeroPlaceHolder();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Reconstruct_230_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((PCHit*) G__getstructoffset())->zeroPCHit();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Reconstruct_230_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   PCHit* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new PCHit(*(PCHit*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_PCHit));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef PCHit G__TPCHit;
static int G__Reconstruct_230_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (PCHit*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((PCHit*) (soff+(sizeof(PCHit)*i)))->~G__TPCHit();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (PCHit*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((PCHit*) (soff))->~G__TPCHit();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Reconstruct_230_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PCHit* dest = (PCHit*) G__getstructoffset();
   *dest = *(PCHit*) libp->para[0].ref;
   const PCHit& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* PCHit::SortByPC */
// automatic default constructor
static int G__Reconstruct_231_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PCHit::SortByPC *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PCHit::SortByPC[n];
     } else {
       p = new((void*) gvp) PCHit::SortByPC[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PCHit::SortByPC;
     } else {
       p = new((void*) gvp) PCHit::SortByPC;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_PCHitcLcLSortByPC));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Reconstruct_231_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   PCHit::SortByPC* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new PCHit::SortByPC(*(PCHit::SortByPC*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_PCHitcLcLSortByPC));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef PCHit::SortByPC G__TPCHitcLcLSortByPC;
static int G__Reconstruct_231_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (PCHit::SortByPC*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((PCHit::SortByPC*) (soff+(sizeof(PCHit::SortByPC)*i)))->~G__TPCHitcLcLSortByPC();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (PCHit::SortByPC*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((PCHit::SortByPC*) (soff))->~G__TPCHitcLcLSortByPC();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Reconstruct_231_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PCHit::SortByPC* dest = (PCHit::SortByPC*) G__getstructoffset();
   *dest = *(PCHit::SortByPC*) libp->para[0].ref;
   const PCHit::SortByPC& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SETTINGS */
static int G__Reconstruct_236_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SETTINGS* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SETTINGS[n];
     } else {
       p = new((void*) gvp) SETTINGS[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SETTINGS;
     } else {
       p = new((void*) gvp) SETTINGS;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_SETTINGS));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Reconstruct_236_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SETTINGS* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SETTINGS(*(SETTINGS*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_SETTINGS));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SETTINGS G__TSETTINGS;
static int G__Reconstruct_236_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SETTINGS*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SETTINGS*) (soff+(sizeof(SETTINGS)*i)))->~G__TSETTINGS();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SETTINGS*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SETTINGS*) (soff))->~G__TSETTINGS();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Reconstruct_236_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SETTINGS* dest = (SETTINGS*) G__getstructoffset();
   *dest = *(SETTINGS*) libp->para[0].ref;
   const SETTINGS& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* SETTINGS::set_values */
// automatic default constructor
static int G__Reconstruct_237_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SETTINGS::set_values *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SETTINGS::set_values[n];
     } else {
       p = new((void*) gvp) SETTINGS::set_values[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SETTINGS::set_values;
     } else {
       p = new((void*) gvp) SETTINGS::set_values;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_SETTINGScLcLset_values));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Reconstruct_237_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SETTINGS::set_values* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SETTINGS::set_values(*(SETTINGS::set_values*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_SETTINGScLcLset_values));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SETTINGS::set_values G__TSETTINGScLcLset_values;
static int G__Reconstruct_237_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SETTINGS::set_values*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SETTINGS::set_values*) (soff+(sizeof(SETTINGS::set_values)*i)))->~G__TSETTINGScLcLset_values();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SETTINGS::set_values*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SETTINGS::set_values*) (soff))->~G__TSETTINGScLcLset_values();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Reconstruct_237_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SETTINGS::set_values* dest = (SETTINGS::set_values*) G__getstructoffset();
   *dest = *(SETTINGS::set_values*) libp->para[0].ref;
   const SETTINGS::set_values& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Track */
static int G__Reconstruct_238_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Track* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Track[n];
     } else {
       p = new((void*) gvp) Track[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Track;
     } else {
       p = new((void*) gvp) Track;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_Track));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Reconstruct_238_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Track*) G__getstructoffset())->zeroPlaceHolder();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Reconstruct_238_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Track*) G__getstructoffset())->zeroTrack();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Reconstruct_238_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Track* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Track(*(Track*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_Track));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Track G__TTrack;
static int G__Reconstruct_238_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Track*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Track*) (soff+(sizeof(Track)*i)))->~G__TTrack();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Track*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Track*) (soff))->~G__TTrack();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Reconstruct_238_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Track* dest = (Track*) G__getstructoffset();
   *dest = *(Track*) libp->para[0].ref;
   const Track& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Track::TrackEvent */
// automatic default constructor
static int G__Reconstruct_239_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Track::TrackEvent *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Track::TrackEvent[n];
     } else {
       p = new((void*) gvp) Track::TrackEvent[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Track::TrackEvent;
     } else {
       p = new((void*) gvp) Track::TrackEvent;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_TrackcLcLTrackEvent));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Reconstruct_239_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Track::TrackEvent* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Track::TrackEvent(*(Track::TrackEvent*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_TrackcLcLTrackEvent));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Track::TrackEvent G__TTrackcLcLTrackEvent;
static int G__Reconstruct_239_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Track::TrackEvent*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Track::TrackEvent*) (soff+(sizeof(Track::TrackEvent)*i)))->~G__TTrackcLcLTrackEvent();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Track::TrackEvent*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Track::TrackEvent*) (soff))->~G__TTrackcLcLTrackEvent();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Reconstruct_239_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Track::TrackEvent* dest = (Track::TrackEvent*) G__getstructoffset();
   *dest = *(Track::TrackEvent*) libp->para[0].ref;
   const Track::TrackEvent& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Track::Silicon_Event */
// automatic default constructor
static int G__Reconstruct_240_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Track::Silicon_Event *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Track::Silicon_Event[n];
     } else {
       p = new((void*) gvp) Track::Silicon_Event[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Track::Silicon_Event;
     } else {
       p = new((void*) gvp) Track::Silicon_Event;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_TrackcLcLSilicon_Event));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Reconstruct_240_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Track::Silicon_Event* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Track::Silicon_Event(*(Track::Silicon_Event*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_TrackcLcLSilicon_Event));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Track::Silicon_Event G__TTrackcLcLSilicon_Event;
static int G__Reconstruct_240_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Track::Silicon_Event*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Track::Silicon_Event*) (soff+(sizeof(Track::Silicon_Event)*i)))->~G__TTrackcLcLSilicon_Event();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Track::Silicon_Event*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Track::Silicon_Event*) (soff))->~G__TTrackcLcLSilicon_Event();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Reconstruct_240_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Track::Silicon_Event* dest = (Track::Silicon_Event*) G__getstructoffset();
   *dest = *(Track::Silicon_Event*) libp->para[0].ref;
   const Track::Silicon_Event& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Track::PropCounter_Event */
// automatic default constructor
static int G__Reconstruct_241_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Track::PropCounter_Event *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Track::PropCounter_Event[n];
     } else {
       p = new((void*) gvp) Track::PropCounter_Event[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Track::PropCounter_Event;
     } else {
       p = new((void*) gvp) Track::PropCounter_Event;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_TrackcLcLPropCounter_Event));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Reconstruct_241_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Track::PropCounter_Event* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Track::PropCounter_Event(*(Track::PropCounter_Event*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_TrackcLcLPropCounter_Event));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Track::PropCounter_Event G__TTrackcLcLPropCounter_Event;
static int G__Reconstruct_241_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Track::PropCounter_Event*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Track::PropCounter_Event*) (soff+(sizeof(Track::PropCounter_Event)*i)))->~G__TTrackcLcLPropCounter_Event();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Track::PropCounter_Event*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Track::PropCounter_Event*) (soff))->~G__TTrackcLcLPropCounter_Event();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Reconstruct_241_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Track::PropCounter_Event* dest = (Track::PropCounter_Event*) G__getstructoffset();
   *dest = *(Track::PropCounter_Event*) libp->para[0].ref;
   const Track::PropCounter_Event& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* EnergyLoss */
static int G__Reconstruct_270_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   EnergyLoss* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new EnergyLoss[n];
     } else {
       p = new((void*) gvp) EnergyLoss[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new EnergyLoss;
     } else {
       p = new((void*) gvp) EnergyLoss;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_EnergyLoss));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Reconstruct_270_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   EnergyLoss* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new EnergyLoss(*((string*) G__int(libp->para[0])), (Float_t) G__double(libp->para[1]));
   } else {
     p = new((void*) gvp) EnergyLoss(*((string*) G__int(libp->para[0])), (Float_t) G__double(libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_EnergyLoss));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Reconstruct_270_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((EnergyLoss*) G__getstructoffset())->GetEnergyLoss((Float_t) G__double(libp->para[0]), (Float_t) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Reconstruct_270_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((EnergyLoss*) G__getstructoffset())->GetEvDCurve((Float_t) G__double(libp->para[0]), (Float_t) G__double(libp->para[1])
, (Int_t) G__int(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Reconstruct_270_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((EnergyLoss*) G__getstructoffset())->GetInitialEnergy((Float_t) G__double(libp->para[0]), (Float_t) G__double(libp->para[1])
, (Float_t) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Reconstruct_270_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((EnergyLoss*) G__getstructoffset())->GetFinalEnergy((Float_t) G__double(libp->para[0]), (Float_t) G__double(libp->para[1])
, (Float_t) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Reconstruct_270_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((EnergyLoss*) G__getstructoffset())->GetPathLength((Float_t) G__double(libp->para[0]), (Float_t) G__double(libp->para[1])
, (Float_t) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Reconstruct_270_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((EnergyLoss*) G__getstructoffset())->GetTimeOfFlight((Float_t) G__double(libp->para[0]), (Float_t) G__double(libp->para[1])
, (Float_t) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Reconstruct_270_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((EnergyLoss*) G__getstructoffset())->LoadSRIMFile(*((string*) G__int(libp->para[0]))));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Reconstruct_270_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((EnergyLoss*) G__getstructoffset())->SetIonMass((Float_t) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Reconstruct_270_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   EnergyLoss* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new EnergyLoss(*(EnergyLoss*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_EnergyLoss));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef EnergyLoss G__TEnergyLoss;
static int G__Reconstruct_270_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (EnergyLoss*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((EnergyLoss*) (soff+(sizeof(EnergyLoss)*i)))->~G__TEnergyLoss();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (EnergyLoss*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((EnergyLoss*) (soff))->~G__TEnergyLoss();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Reconstruct_270_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   EnergyLoss* dest = (EnergyLoss*) G__getstructoffset();
   *dest = *(EnergyLoss*) libp->para[0].ref;
   const EnergyLoss& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reconstruct */
static int G__Reconstruct_271_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reconstruct* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reconstruct[n];
     } else {
       p = new((void*) gvp) Reconstruct[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reconstruct;
     } else {
       p = new((void*) gvp) Reconstruct;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_Reconstruct));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Reconstruct_271_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Reconstruct*) G__getstructoffset())->zeroPlaceHolder();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Reconstruct_271_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Reconstruct*) G__getstructoffset())->zeroReconstruct();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__Reconstruct_271_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Reconstruct*) G__getstructoffset())->ReconstructBe(*(Track*) libp->para[0].ref, (Int_t) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2]), (Int_t) G__int(libp->para[3]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Reconstruct_271_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reconstruct* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reconstruct(*(Reconstruct*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_Reconstruct));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reconstruct G__TReconstruct;
static int G__Reconstruct_271_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reconstruct*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reconstruct*) (soff+(sizeof(Reconstruct)*i)))->~G__TReconstruct();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reconstruct*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reconstruct*) (soff))->~G__TReconstruct();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Reconstruct_271_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reconstruct* dest = (Reconstruct*) G__getstructoffset();
   *dest = *(Reconstruct*) libp->para[0].ref;
   const Reconstruct& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reconstruct::Be8Event */
// automatic default constructor
static int G__Reconstruct_272_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reconstruct::Be8Event *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reconstruct::Be8Event[n];
     } else {
       p = new((void*) gvp) Reconstruct::Be8Event[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reconstruct::Be8Event;
     } else {
       p = new((void*) gvp) Reconstruct::Be8Event;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_ReconstructcLcLBe8Event));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__Reconstruct_272_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reconstruct::Be8Event* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reconstruct::Be8Event(*(Reconstruct::Be8Event*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__ReconstructLN_ReconstructcLcLBe8Event));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reconstruct::Be8Event G__TReconstructcLcLBe8Event;
static int G__Reconstruct_272_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reconstruct::Be8Event*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reconstruct::Be8Event*) (soff+(sizeof(Reconstruct::Be8Event)*i)))->~G__TReconstructcLcLBe8Event();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reconstruct::Be8Event*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reconstruct::Be8Event*) (soff))->~G__TReconstructcLcLBe8Event();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__Reconstruct_272_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reconstruct::Be8Event* dest = (Reconstruct::Be8Event*) G__getstructoffset();
   *dest = *(Reconstruct::Be8Event*) libp->para[0].ref;
   const Reconstruct::Be8Event& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */

/*********************************************************
* Member function Stub
*********************************************************/

/* SiHit */

/* SiHit::SortByDetector */

/* SiHit::SortByHit */

/* PCHit */

/* PCHit::SortByPC */

/* SETTINGS */

/* SETTINGS::set_values */

/* Track */

/* Track::TrackEvent */

/* Track::Silicon_Event */

/* Track::PropCounter_Event */

/* EnergyLoss */

/* Reconstruct */

/* Reconstruct::Be8Event */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfuncReconstruct {
 public:
  G__Sizep2memfuncReconstruct(): p(&G__Sizep2memfuncReconstruct::sizep2memfunc) {}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfuncReconstruct::*p)();
};

size_t G__get_sizep2memfuncReconstruct()
{
  G__Sizep2memfuncReconstruct a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */

/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritanceReconstruct() {

   /* Setting up class inheritance */
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetableReconstruct() {

   /* Setting up typedef entry */
   G__search_typename2("Int_t",105,-1,0,-1);
   G__setnewtype(-1,"Signed integer 4 bytes (int)",0);
   G__search_typename2("Float_t",102,-1,0,-1);
   G__setnewtype(-1,"Float 4 bytes (float)",0);
   G__search_typename2("Double_t",100,-1,0,-1);
   G__setnewtype(-1,"Double 8 bytes",0);
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__ReconstructLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__ReconstructLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__ReconstructLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TVirtualArray*>",117,G__get_linked_tagnum(&G__ReconstructLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__ReconstructLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__ReconstructLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__ReconstructLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__ReconstructLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<std::bidirectional_iterator_tag,TObject*,std::ptrdiff_t,const TObject**,const TObject*&>",117,G__get_linked_tagnum(&G__ReconstructLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*,std::ptrdiff_t,const TObject**,const TObject*&>",117,G__get_linked_tagnum(&G__ReconstructLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*>",117,G__get_linked_tagnum(&G__ReconstructLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*,long>",117,G__get_linked_tagnum(&G__ReconstructLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*,long,const TObject**>",117,G__get_linked_tagnum(&G__ReconstructLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Int_t>",117,G__get_linked_tagnum(&G__ReconstructLN_vectorlEintcOallocatorlEintgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__ReconstructLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEintcOallocatorlEintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__ReconstructLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEintcOallocatorlEintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<int>",117,G__get_linked_tagnum(&G__ReconstructLN_vectorlEintcOallocatorlEintgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Double_t>",117,G__get_linked_tagnum(&G__ReconstructLN_vectorlEdoublecOallocatorlEdoublegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<SortByDetector>",117,G__get_linked_tagnum(&G__ReconstructLN_vectorlESiHitcLcLSortByDetectorcOallocatorlESiHitcLcLSortByDetectorgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__ReconstructLN_reverse_iteratorlEvectorlESiHitcLcLSortByDetectorcOallocatorlESiHitcLcLSortByDetectorgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__ReconstructLN_vectorlESiHitcLcLSortByDetectorcOallocatorlESiHitcLcLSortByDetectorgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__ReconstructLN_reverse_iteratorlEvectorlESiHitcLcLSortByDetectorcOallocatorlESiHitcLcLSortByDetectorgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__ReconstructLN_vectorlESiHitcLcLSortByDetectorcOallocatorlESiHitcLcLSortByDetectorgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<SiHit::SortByDetector>",117,G__get_linked_tagnum(&G__ReconstructLN_vectorlESiHitcLcLSortByDetectorcOallocatorlESiHitcLcLSortByDetectorgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<SortByHit>",117,G__get_linked_tagnum(&G__ReconstructLN_vectorlESiHitcLcLSortByHitcOallocatorlESiHitcLcLSortByHitgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__ReconstructLN_reverse_iteratorlEvectorlESiHitcLcLSortByHitcOallocatorlESiHitcLcLSortByHitgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__ReconstructLN_vectorlESiHitcLcLSortByHitcOallocatorlESiHitcLcLSortByHitgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__ReconstructLN_reverse_iteratorlEvectorlESiHitcLcLSortByHitcOallocatorlESiHitcLcLSortByHitgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__ReconstructLN_vectorlESiHitcLcLSortByHitcOallocatorlESiHitcLcLSortByHitgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<SiHit::SortByHit>",117,G__get_linked_tagnum(&G__ReconstructLN_vectorlESiHitcLcLSortByHitcOallocatorlESiHitcLcLSortByHitgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<SortByPC>",117,G__get_linked_tagnum(&G__ReconstructLN_vectorlEPCHitcLcLSortByPCcOallocatorlEPCHitcLcLSortByPCgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__ReconstructLN_reverse_iteratorlEvectorlEPCHitcLcLSortByPCcOallocatorlEPCHitcLcLSortByPCgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEPCHitcLcLSortByPCcOallocatorlEPCHitcLcLSortByPCgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__ReconstructLN_reverse_iteratorlEvectorlEPCHitcLcLSortByPCcOallocatorlEPCHitcLcLSortByPCgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEPCHitcLcLSortByPCcOallocatorlEPCHitcLcLSortByPCgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<PCHit::SortByPC>",117,G__get_linked_tagnum(&G__ReconstructLN_vectorlEPCHitcLcLSortByPCcOallocatorlEPCHitcLcLSortByPCgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TrackEvent>",117,G__get_linked_tagnum(&G__ReconstructLN_vectorlETrackcLcLTrackEventcOallocatorlETrackcLcLTrackEventgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__ReconstructLN_reverse_iteratorlEvectorlETrackcLcLTrackEventcOallocatorlETrackcLcLTrackEventgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__ReconstructLN_vectorlETrackcLcLTrackEventcOallocatorlETrackcLcLTrackEventgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__ReconstructLN_reverse_iteratorlEvectorlETrackcLcLTrackEventcOallocatorlETrackcLcLTrackEventgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__ReconstructLN_vectorlETrackcLcLTrackEventcOallocatorlETrackcLcLTrackEventgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Track::TrackEvent>",117,G__get_linked_tagnum(&G__ReconstructLN_vectorlETrackcLcLTrackEventcOallocatorlETrackcLcLTrackEventgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Silicon_Event>",117,G__get_linked_tagnum(&G__ReconstructLN_vectorlETrackcLcLSilicon_EventcOallocatorlETrackcLcLSilicon_EventgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__ReconstructLN_reverse_iteratorlEvectorlETrackcLcLSilicon_EventcOallocatorlETrackcLcLSilicon_EventgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__ReconstructLN_vectorlETrackcLcLSilicon_EventcOallocatorlETrackcLcLSilicon_EventgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__ReconstructLN_reverse_iteratorlEvectorlETrackcLcLSilicon_EventcOallocatorlETrackcLcLSilicon_EventgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__ReconstructLN_vectorlETrackcLcLSilicon_EventcOallocatorlETrackcLcLSilicon_EventgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Track::Silicon_Event>",117,G__get_linked_tagnum(&G__ReconstructLN_vectorlETrackcLcLSilicon_EventcOallocatorlETrackcLcLSilicon_EventgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<PropCounter_Event>",117,G__get_linked_tagnum(&G__ReconstructLN_vectorlETrackcLcLPropCounter_EventcOallocatorlETrackcLcLPropCounter_EventgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__ReconstructLN_reverse_iteratorlEvectorlETrackcLcLPropCounter_EventcOallocatorlETrackcLcLPropCounter_EventgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__ReconstructLN_vectorlETrackcLcLPropCounter_EventcOallocatorlETrackcLcLPropCounter_EventgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__ReconstructLN_reverse_iteratorlEvectorlETrackcLcLPropCounter_EventcOallocatorlETrackcLcLPropCounter_EventgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__ReconstructLN_vectorlETrackcLcLPropCounter_EventcOallocatorlETrackcLcLPropCounter_EventgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Track::PropCounter_Event>",117,G__get_linked_tagnum(&G__ReconstructLN_vectorlETrackcLcLPropCounter_EventcOallocatorlETrackcLcLPropCounter_EventgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TVectorT<Float_t>",117,G__get_linked_tagnum(&G__ReconstructLN_TVectorTlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TVectorT<Double_t>",117,G__get_linked_tagnum(&G__ReconstructLN_TVectorTlEdoublegR),0,-1);
   G__setnewtype(-1,NULL,0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* SiHit */
static void G__setup_memvarSiHit(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__ReconstructLN_SiHit));
   { SiHit *p; p=(SiHit*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->NSiHits)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"NSiHits=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->det_place_holder)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_SiHitcLcLSortByDetector),-1,-1,1,"det_place_holder=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->hit_place_holder)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_SiHitcLcLSortByHit),-1,-1,1,"hit_place_holder=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Detector)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlESiHitcLcLSortByDetectorcOallocatorlESiHitcLcLSortByDetectorgRsPgR),G__defined_typename("vector<SortByDetector>"),-1,1,"Detector=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Hit)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlESiHitcLcLSortByHitcOallocatorlESiHitcLcLSortByHitgRsPgR),G__defined_typename("vector<SortByHit>"),-1,1,"Hit=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ReadDet)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlESiHitcLcLSortByDetectorcOallocatorlESiHitcLcLSortByDetectorgRsPgR),G__defined_typename("vector<SortByDetector>"),-1,1,"ReadDet=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ReadHit)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlESiHitcLcLSortByHitcOallocatorlESiHitcLcLSortByHitgRsPgR),G__defined_typename("vector<SortByHit>"),-1,1,"ReadHit=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* SiHit::SortByDetector */
static void G__setup_memvarSiHitcLcLSortByDetector(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__ReconstructLN_SiHitcLcLSortByDetector));
   { SiHit::SortByDetector *p; p=(SiHit::SortByDetector*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->DetID)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"DetID=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->UpMult)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"UpMult=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->DownMult)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"DownMult=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BackMult)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"BackMult=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->HitType)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"HitType=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->UpChNum)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEintcOallocatorlEintgRsPgR),G__defined_typename("vector<Int_t>"),-1,1,"UpChNum=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->DownChNum)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEintcOallocatorlEintgRsPgR),G__defined_typename("vector<Int_t>"),-1,1,"DownChNum=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BackChNum)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEintcOallocatorlEintgRsPgR),G__defined_typename("vector<Int_t>"),-1,1,"BackChNum=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EnergyUp_Raw)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<Double_t>"),-1,1,"EnergyUp_Raw=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EnergyDown_Raw)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<Double_t>"),-1,1,"EnergyDown_Raw=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EnergyBack_Raw)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<Double_t>"),-1,1,"EnergyBack_Raw=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EnergyUp_Pulser)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<Double_t>"),-1,1,"EnergyUp_Pulser=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EnergyDown_Pulser)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<Double_t>"),-1,1,"EnergyDown_Pulser=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EnergyBack_Pulser)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<Double_t>"),-1,1,"EnergyBack_Pulser=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EnergyUp_Rel)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<Double_t>"),-1,1,"EnergyUp_Rel=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EnergyDown_Rel)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<Double_t>"),-1,1,"EnergyDown_Rel=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EnergyBack_Rel)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<Double_t>"),-1,1,"EnergyBack_Rel=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EnergyUp_Cal)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<Double_t>"),-1,1,"EnergyUp_Cal=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EnergyDown_Cal)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<Double_t>"),-1,1,"EnergyDown_Cal=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EnergyBack_Cal)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<Double_t>"),-1,1,"EnergyBack_Cal=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->TimeUp)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<Double_t>"),-1,1,"TimeUp=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->TimeDown)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<Double_t>"),-1,1,"TimeDown=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->TimeBack)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<Double_t>"),-1,1,"TimeBack=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* SiHit::SortByHit */
static void G__setup_memvarSiHitcLcLSortByHit(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__ReconstructLN_SiHitcLcLSortByHit));
   { SiHit::SortByHit *p; p=(SiHit::SortByHit*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->NHitsInDet)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"NHitsInDet=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->DetID)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"DetID=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Flag)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"Flag=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->HitType)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"HitType=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->FrontChannel)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"FrontChannel=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BackChannel)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"BackChannel=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EnergyBack)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"EnergyBack=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EnergyFront)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"EnergyFront=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Energy)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"Energy=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Time)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"Time=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->X)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"X=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Y)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"Y=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Z)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"Z=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->XW)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"XW=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->YW)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"YW=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ZW)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"ZW=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RW)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"RW=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PhiW)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"PhiW=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RFSubtract)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"RFSubtract=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->TrackType)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"TrackType=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* PCHit */
static void G__setup_memvarPCHit(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__ReconstructLN_PCHit));
   { PCHit *p; p=(PCHit*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->NPCHits)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"NPCHits=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->pc_place_holder)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_PCHitcLcLSortByPC),-1,-1,1,"pc_place_holder=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Hit)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEPCHitcLcLSortByPCcOallocatorlEPCHitcLcLSortByPCgRsPgR),G__defined_typename("vector<SortByPC>"),-1,1,"Hit=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ReadHit)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlEPCHitcLcLSortByPCcOallocatorlEPCHitcLcLSortByPCgRsPgR),G__defined_typename("vector<SortByPC>"),-1,1,"ReadHit=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* PCHit::SortByPC */
static void G__setup_memvarPCHitcLcLSortByPC(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__ReconstructLN_PCHitcLcLSortByPC));
   { PCHit::SortByPC *p; p=(PCHit::SortByPC*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->WireID)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"WireID=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Down)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"Down=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Up)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"Up=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->DownVoltage)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"DownVoltage=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->UpVoltage)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"UpVoltage=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Energy)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"Energy=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Z)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"Z=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->XW)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"XW=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->YW)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"YW=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ZW)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"ZW=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RW)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"RW=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PhiW)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"PhiW=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->TrackType)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"TrackType=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* SETTINGS */
static void G__setup_memvarSETTINGS(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__ReconstructLN_SETTINGS));
   { SETTINGS *p; p=(SETTINGS*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->set_val)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_SETTINGScLcLset_values),-1,-1,1,"set_val=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* SETTINGS::set_values */
static void G__setup_memvarSETTINGScLcLset_values(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__ReconstructLN_SETTINGScLcLset_values));
   { SETTINGS::set_values *p; p=(SETTINGS::set_values*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->X3Pulser_Offset)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"X3Pulser_Offset[24][12]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->X3Pulser_Slope)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"X3Pulser_Slope[24][12]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->X3RelativeGains)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"X3RelativeGains[24][12]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->X3FinalFix)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"X3FinalFix[24][12]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->X3Geometry_Up)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"X3Geometry_Up[24][4][4]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->X3Geometry_Down)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"X3Geometry_Down[24][4][4]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->QQQPulser_Offset)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"QQQPulser_Offset[4][32]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->QQQPulser_Slope)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"QQQPulser_Slope[4][32]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->QQQRelativeGains)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"QQQRelativeGains[4][32]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->QQQFinalFix)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"QQQFinalFix[4][32]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->SiAlphaCal)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"SiAlphaCal[28]=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Track */
static void G__setup_memvarTrack(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__ReconstructLN_Track));
   { Track *p; p=(Track*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->NTracks)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"NTracks=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->NTracks1)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"NTracks1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->NTracks2)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"NTracks2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->NTracks3)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"NTracks3=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->track_place_holder)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_TrackcLcLTrackEvent),-1,-1,1,"track_place_holder=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->si_place_holder)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_TrackcLcLSilicon_Event),-1,-1,1,"si_place_holder=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->pc_place_holder)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_TrackcLcLPropCounter_Event),-1,-1,1,"pc_place_holder=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->TrEvent)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlETrackcLcLTrackEventcOallocatorlETrackcLcLTrackEventgRsPgR),G__defined_typename("vector<TrackEvent>"),-1,1,"TrEvent=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ReadTrEvent)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlETrackcLcLTrackEventcOallocatorlETrackcLcLTrackEventgRsPgR),G__defined_typename("vector<TrackEvent>"),-1,1,"ReadTrEvent=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->SiEvent)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlETrackcLcLSilicon_EventcOallocatorlETrackcLcLSilicon_EventgRsPgR),G__defined_typename("vector<Silicon_Event>"),-1,1,"SiEvent=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ReadSiEvent)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlETrackcLcLSilicon_EventcOallocatorlETrackcLcLSilicon_EventgRsPgR),G__defined_typename("vector<Silicon_Event>"),-1,1,"ReadSiEvent=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PCEvent)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlETrackcLcLPropCounter_EventcOallocatorlETrackcLcLPropCounter_EventgRsPgR),G__defined_typename("vector<PropCounter_Event>"),-1,1,"PCEvent=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ReadPCEvent)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__ReconstructLN_vectorlETrackcLcLPropCounter_EventcOallocatorlETrackcLcLPropCounter_EventgRsPgR),G__defined_typename("vector<PropCounter_Event>"),-1,1,"ReadPCEvent=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Track::TrackEvent */
static void G__setup_memvarTrackcLcLTrackEvent(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__ReconstructLN_TrackcLcLTrackEvent));
   { Track::TrackEvent *p; p=(Track::TrackEvent*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->TrackType)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"TrackType=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->DetID)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"DetID=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->WireID)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"WireID=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->SiEnergy)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"SiEnergy=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->SiZ)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"SiZ=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->SiR)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"SiR=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->SiPhi)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"SiPhi=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PCEnergy)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"PCEnergy=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PCZ)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"PCZ=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PCR)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"PCR=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PCPhi)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"PCPhi=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->IntPoint)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"IntPoint=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PathLength)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"PathLength=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Theta)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"Theta=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Phi)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"Phi=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BeamEnergy)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"BeamEnergy=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PCZ_Ref)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"PCZ_Ref=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Track::Silicon_Event */
static void G__setup_memvarTrackcLcLSilicon_Event(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__ReconstructLN_TrackcLcLSilicon_Event));
   { Track::Silicon_Event *p; p=(Track::Silicon_Event*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->TrackType)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"TrackType=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->DetID)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"DetID=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->SiEnergy)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"SiEnergy=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->SiZ)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"SiZ=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->SiR)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"SiR=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->SiPhi)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"SiPhi=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Track::PropCounter_Event */
static void G__setup_memvarTrackcLcLPropCounter_Event(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__ReconstructLN_TrackcLcLPropCounter_Event));
   { Track::PropCounter_Event *p; p=(Track::PropCounter_Event*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->TrackType)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"TrackType=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->WireID)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"WireID=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PCEnergy)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"PCEnergy=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PCZ)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"PCZ=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PCR)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"PCR=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PCPhi)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"PCPhi=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* EnergyLoss */
static void G__setup_memvarEnergyLoss(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__ReconstructLN_EnergyLoss));
   { EnergyLoss *p; p=(EnergyLoss*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->GoodELossFile)-(long)(p)),103,0,0,-1,-1,-1,1,"GoodELossFile=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EvD)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__ReconstructLN_TGraph),-1,-1,1,"EvD=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,G__defined_typename("Double_t"),-1,4,"c=",0,(char*)NULL);
   G__memvar_setup((void*)0,68,0,0,-1,G__defined_typename("Double_t"),-1,4,"IonEnergy=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,G__defined_typename("Double_t"),-1,4,"IonMass=",0,(char*)NULL);
   G__memvar_setup((void*)0,68,0,0,-1,G__defined_typename("Double_t"),-1,4,"dEdx_e=",0,(char*)NULL);
   G__memvar_setup((void*)0,68,0,0,-1,G__defined_typename("Double_t"),-1,4,"dEdx_n=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,4,"points=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,4,"last_point=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"Energy_in_range=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Reconstruct */
static void G__setup_memvarReconstruct(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__ReconstructLN_Reconstruct));
   { Reconstruct *p; p=(Reconstruct*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->BeEvent)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__ReconstructLN_ReconstructcLcLBe8Event),-1,-1,1,"BeEvent=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Reconstruct::Be8Event */
static void G__setup_memvarReconstructcLcLBe8Event(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__ReconstructLN_ReconstructcLcLBe8Event));
   { Reconstruct::Be8Event *p; p=(Reconstruct::Be8Event*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->DiffIntPoint)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"DiffIntPoint=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->SiEnergy_tot)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"SiEnergy_tot=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PCEnergy_tot)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"PCEnergy_tot=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Energy_tot)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"Energy_tot=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->AlphaAngle)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"AlphaAngle=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BeTheta)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"BeTheta=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BePhi)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"BePhi=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->BeKE)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"BeKE=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Ex)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"Ex=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->AvgBeamEnergy)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"AvgBeamEnergy=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvarReconstruct() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncSiHit(void) {
   /* SiHit */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__ReconstructLN_SiHit));
   G__memfunc_setup("SiHit",481,G__Reconstruct_215_0_1, 105, G__get_linked_tagnum(&G__ReconstructLN_SiHit), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("zeroPlaceHolder",1539,G__Reconstruct_215_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("zeroSiHit",929,G__Reconstruct_215_0_3, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SiHit", 481, G__Reconstruct_215_0_4, (int) ('i'), G__get_linked_tagnum(&G__ReconstructLN_SiHit), -1, 0, 1, 1, 1, 0, "u 'SiHit' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SiHit", 607, G__Reconstruct_215_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Reconstruct_215_0_6, (int) ('u'), G__get_linked_tagnum(&G__ReconstructLN_SiHit), -1, 1, 1, 1, 1, 0, "u 'SiHit' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSiHitcLcLSortByDetector(void) {
   /* SiHit::SortByDetector */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__ReconstructLN_SiHitcLcLSortByDetector));
   // automatic default constructor
   G__memfunc_setup("SortByDetector", 1437, G__Reconstruct_216_0_1, (int) ('i'), G__get_linked_tagnum(&G__ReconstructLN_SiHitcLcLSortByDetector), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SortByDetector", 1437, G__Reconstruct_216_0_2, (int) ('i'), G__get_linked_tagnum(&G__ReconstructLN_SiHitcLcLSortByDetector), -1, 0, 1, 1, 1, 0, "u 'SiHit::SortByDetector' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SortByDetector", 1563, G__Reconstruct_216_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Reconstruct_216_0_4, (int) ('u'), G__get_linked_tagnum(&G__ReconstructLN_SiHitcLcLSortByDetector), -1, 1, 1, 1, 1, 0, "u 'SiHit::SortByDetector' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSiHitcLcLSortByHit(void) {
   /* SiHit::SortByHit */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__ReconstructLN_SiHitcLcLSortByHit));
   // automatic default constructor
   G__memfunc_setup("SortByHit", 904, G__Reconstruct_221_0_1, (int) ('i'), G__get_linked_tagnum(&G__ReconstructLN_SiHitcLcLSortByHit), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SortByHit", 904, G__Reconstruct_221_0_2, (int) ('i'), G__get_linked_tagnum(&G__ReconstructLN_SiHitcLcLSortByHit), -1, 0, 1, 1, 1, 0, "u 'SiHit::SortByHit' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SortByHit", 1030, G__Reconstruct_221_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Reconstruct_221_0_4, (int) ('u'), G__get_linked_tagnum(&G__ReconstructLN_SiHitcLcLSortByHit), -1, 1, 1, 1, 1, 0, "u 'SiHit::SortByHit' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncPCHit(void) {
   /* PCHit */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__ReconstructLN_PCHit));
   G__memfunc_setup("PCHit",440,G__Reconstruct_230_0_1, 105, G__get_linked_tagnum(&G__ReconstructLN_PCHit), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("zeroPlaceHolder",1539,G__Reconstruct_230_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("zeroPCHit",888,G__Reconstruct_230_0_3, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("PCHit", 440, G__Reconstruct_230_0_4, (int) ('i'), G__get_linked_tagnum(&G__ReconstructLN_PCHit), -1, 0, 1, 1, 1, 0, "u 'PCHit' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PCHit", 566, G__Reconstruct_230_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Reconstruct_230_0_6, (int) ('u'), G__get_linked_tagnum(&G__ReconstructLN_PCHit), -1, 1, 1, 1, 1, 0, "u 'PCHit' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncPCHitcLcLSortByPC(void) {
   /* PCHit::SortByPC */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__ReconstructLN_PCHitcLcLSortByPC));
   // automatic default constructor
   G__memfunc_setup("SortByPC", 758, G__Reconstruct_231_0_1, (int) ('i'), G__get_linked_tagnum(&G__ReconstructLN_PCHitcLcLSortByPC), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SortByPC", 758, G__Reconstruct_231_0_2, (int) ('i'), G__get_linked_tagnum(&G__ReconstructLN_PCHitcLcLSortByPC), -1, 0, 1, 1, 1, 0, "u 'PCHit::SortByPC' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SortByPC", 884, G__Reconstruct_231_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Reconstruct_231_0_4, (int) ('u'), G__get_linked_tagnum(&G__ReconstructLN_PCHitcLcLSortByPC), -1, 1, 1, 1, 1, 0, "u 'PCHit::SortByPC' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSETTINGS(void) {
   /* SETTINGS */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__ReconstructLN_SETTINGS));
   G__memfunc_setup("SETTINGS",625,G__Reconstruct_236_0_1, 105, G__get_linked_tagnum(&G__ReconstructLN_SETTINGS), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SETTINGS", 625, G__Reconstruct_236_0_2, (int) ('i'), G__get_linked_tagnum(&G__ReconstructLN_SETTINGS), -1, 0, 1, 1, 1, 0, "u 'SETTINGS' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SETTINGS", 751, G__Reconstruct_236_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Reconstruct_236_0_4, (int) ('u'), G__get_linked_tagnum(&G__ReconstructLN_SETTINGS), -1, 1, 1, 1, 1, 0, "u 'SETTINGS' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSETTINGScLcLset_values(void) {
   /* SETTINGS::set_values */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__ReconstructLN_SETTINGScLcLset_values));
   // automatic default constructor
   G__memfunc_setup("set_values", 1083, G__Reconstruct_237_0_1, (int) ('i'), G__get_linked_tagnum(&G__ReconstructLN_SETTINGScLcLset_values), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("set_values", 1083, G__Reconstruct_237_0_2, (int) ('i'), G__get_linked_tagnum(&G__ReconstructLN_SETTINGScLcLset_values), -1, 0, 1, 1, 1, 0, "u 'SETTINGS::set_values' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~set_values", 1209, G__Reconstruct_237_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Reconstruct_237_0_4, (int) ('u'), G__get_linked_tagnum(&G__ReconstructLN_SETTINGScLcLset_values), -1, 1, 1, 1, 1, 0, "u 'SETTINGS::set_values' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTrack(void) {
   /* Track */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__ReconstructLN_Track));
   G__memfunc_setup("Track",501,G__Reconstruct_238_0_1, 105, G__get_linked_tagnum(&G__ReconstructLN_Track), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("zeroPlaceHolder",1539,G__Reconstruct_238_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("zeroTrack",949,G__Reconstruct_238_0_3, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Track", 501, G__Reconstruct_238_0_4, (int) ('i'), G__get_linked_tagnum(&G__ReconstructLN_Track), -1, 0, 1, 1, 1, 0, "u 'Track' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Track", 627, G__Reconstruct_238_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Reconstruct_238_0_6, (int) ('u'), G__get_linked_tagnum(&G__ReconstructLN_Track), -1, 1, 1, 1, 1, 0, "u 'Track' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTrackcLcLTrackEvent(void) {
   /* Track::TrackEvent */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__ReconstructLN_TrackcLcLTrackEvent));
   // automatic default constructor
   G__memfunc_setup("TrackEvent", 1015, G__Reconstruct_239_0_1, (int) ('i'), G__get_linked_tagnum(&G__ReconstructLN_TrackcLcLTrackEvent), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TrackEvent", 1015, G__Reconstruct_239_0_2, (int) ('i'), G__get_linked_tagnum(&G__ReconstructLN_TrackcLcLTrackEvent), -1, 0, 1, 1, 1, 0, "u 'Track::TrackEvent' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TrackEvent", 1141, G__Reconstruct_239_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Reconstruct_239_0_4, (int) ('u'), G__get_linked_tagnum(&G__ReconstructLN_TrackcLcLTrackEvent), -1, 1, 1, 1, 1, 0, "u 'Track::TrackEvent' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTrackcLcLSilicon_Event(void) {
   /* Track::Silicon_Event */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__ReconstructLN_TrackcLcLSilicon_Event));
   // automatic default constructor
   G__memfunc_setup("Silicon_Event", 1330, G__Reconstruct_240_0_1, (int) ('i'), G__get_linked_tagnum(&G__ReconstructLN_TrackcLcLSilicon_Event), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Silicon_Event", 1330, G__Reconstruct_240_0_2, (int) ('i'), G__get_linked_tagnum(&G__ReconstructLN_TrackcLcLSilicon_Event), -1, 0, 1, 1, 1, 0, "u 'Track::Silicon_Event' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Silicon_Event", 1456, G__Reconstruct_240_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Reconstruct_240_0_4, (int) ('u'), G__get_linked_tagnum(&G__ReconstructLN_TrackcLcLSilicon_Event), -1, 1, 1, 1, 1, 0, "u 'Track::Silicon_Event' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTrackcLcLPropCounter_Event(void) {
   /* Track::PropCounter_Event */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__ReconstructLN_TrackcLcLPropCounter_Event));
   // automatic default constructor
   G__memfunc_setup("PropCounter_Event", 1762, G__Reconstruct_241_0_1, (int) ('i'), G__get_linked_tagnum(&G__ReconstructLN_TrackcLcLPropCounter_Event), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("PropCounter_Event", 1762, G__Reconstruct_241_0_2, (int) ('i'), G__get_linked_tagnum(&G__ReconstructLN_TrackcLcLPropCounter_Event), -1, 0, 1, 1, 1, 0, "u 'Track::PropCounter_Event' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PropCounter_Event", 1888, G__Reconstruct_241_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Reconstruct_241_0_4, (int) ('u'), G__get_linked_tagnum(&G__ReconstructLN_TrackcLcLPropCounter_Event), -1, 1, 1, 1, 1, 0, "u 'Track::PropCounter_Event' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncEnergyLoss(void) {
   /* EnergyLoss */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__ReconstructLN_EnergyLoss));
   G__memfunc_setup("EnergyLoss",1035,G__Reconstruct_270_0_1, 105, G__get_linked_tagnum(&G__ReconstructLN_EnergyLoss), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("EnergyLoss",1035,G__Reconstruct_270_0_2, 105, G__get_linked_tagnum(&G__ReconstructLN_EnergyLoss), -1, 0, 2, 1, 1, 0, 
"u 'string' - 0 - Eloss_file f - 'Float_t' 0 - IonMass", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetEnergyLoss",1323,G__Reconstruct_270_0_3, 100, -1, G__defined_typename("Double_t"), 0, 2, 1, 1, 0, 
"f - 'Float_t' 0 - initial_energy f - 'Float_t' 0 - distance", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetEvDCurve",1060,G__Reconstruct_270_0_4, 121, -1, -1, 0, 3, 1, 1, 0, 
"f - 'Float_t' 0 - InitEne f - 'Float_t' 0 - FinalDepth "
"i - 'Int_t' 0 - steps", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetInitialEnergy",1620,G__Reconstruct_270_0_5, 100, -1, G__defined_typename("Double_t"), 0, 3, 1, 1, 0, 
"f - 'Float_t' 0 - FinalEnergy f - 'Float_t' 0 - PathLength "
"f - 'Float_t' 0 - StepSize", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetFinalEnergy",1396,G__Reconstruct_270_0_6, 100, -1, G__defined_typename("Double_t"), 0, 3, 1, 1, 0, 
"f - 'Float_t' 0 - InitialEnergy f - 'Float_t' 0 - PathLength "
"f - 'Float_t' 0 - StepSize", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetPathLength",1295,G__Reconstruct_270_0_7, 100, -1, G__defined_typename("Double_t"), 0, 3, 1, 1, 0, 
"f - 'Float_t' 0 - InitialEnergy f - 'Float_t' 0 - FinalEnergy "
"f - 'Float_t' 0 - DeltaT", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetTimeOfFlight",1474,G__Reconstruct_270_0_8, 100, -1, G__defined_typename("Double_t"), 0, 3, 1, 1, 0, 
"f - 'Float_t' 0 - InitialEnergy f - 'Float_t' 0 - PathLength "
"f - 'Float_t' 0 - StepSize", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("LoadSRIMFile",1083,G__Reconstruct_270_0_9, 103, -1, -1, 0, 1, 1, 1, 0, "u 'string' - 0 - FileName", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetIonMass",998,G__Reconstruct_270_0_10, 121, -1, -1, 0, 1, 1, 1, 0, "f - 'Float_t' 0 - IonMass", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("EnergyLoss", 1035, G__Reconstruct_270_0_11, (int) ('i'), G__get_linked_tagnum(&G__ReconstructLN_EnergyLoss), -1, 0, 1, 1, 1, 0, "u 'EnergyLoss' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~EnergyLoss", 1161, G__Reconstruct_270_0_12, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Reconstruct_270_0_13, (int) ('u'), G__get_linked_tagnum(&G__ReconstructLN_EnergyLoss), -1, 1, 1, 1, 1, 0, "u 'EnergyLoss' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReconstruct(void) {
   /* Reconstruct */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__ReconstructLN_Reconstruct));
   G__memfunc_setup("Reconstruct",1180,G__Reconstruct_271_0_1, 105, G__get_linked_tagnum(&G__ReconstructLN_Reconstruct), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("zeroPlaceHolder",1539,G__Reconstruct_271_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("zeroReconstruct",1628,G__Reconstruct_271_0_3, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ReconstructBe",1347,G__Reconstruct_271_0_4, 121, -1, -1, 0, 4, 1, 1, 0, 
"u 'Track' - 1 - Tr i - 'Int_t' 0 - alpha1 "
"i - 'Int_t' 0 - alpha2 i - 'Int_t' 0 - proton", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Reconstruct", 1180, G__Reconstruct_271_0_5, (int) ('i'), G__get_linked_tagnum(&G__ReconstructLN_Reconstruct), -1, 0, 1, 1, 1, 0, "u 'Reconstruct' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Reconstruct", 1306, G__Reconstruct_271_0_6, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Reconstruct_271_0_7, (int) ('u'), G__get_linked_tagnum(&G__ReconstructLN_Reconstruct), -1, 1, 1, 1, 1, 0, "u 'Reconstruct' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReconstructcLcLBe8Event(void) {
   /* Reconstruct::Be8Event */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__ReconstructLN_ReconstructcLcLBe8Event));
   // automatic default constructor
   G__memfunc_setup("Be8Event", 737, G__Reconstruct_272_0_1, (int) ('i'), G__get_linked_tagnum(&G__ReconstructLN_ReconstructcLcLBe8Event), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Be8Event", 737, G__Reconstruct_272_0_2, (int) ('i'), G__get_linked_tagnum(&G__ReconstructLN_ReconstructcLcLBe8Event), -1, 0, 1, 1, 1, 0, "u 'Reconstruct::Be8Event' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Be8Event", 863, G__Reconstruct_272_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__Reconstruct_272_0_4, (int) ('u'), G__get_linked_tagnum(&G__ReconstructLN_ReconstructcLcLBe8Event), -1, 1, 1, 1, 1, 0, "u 'Reconstruct::Be8Event' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfuncReconstruct() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

}

static void G__cpp_setup_global1() {
   G__memvar_setup((void*)G__PVOID,112,0,0,-1,-1,-1,1,"MaxPCHits=24",1,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,112,0,0,-1,-1,-1,1,"NPCWires=24",1,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,112,0,0,-1,-1,-1,1,"MaxSiHits=500",1,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,112,0,0,-1,-1,-1,1,"MaxTracks=100",1,(char*)NULL);
}

static void G__cpp_setup_global2() {
   G__memvar_setup((void*)G__PVOID,80,0,0,-1,-1,-1,1,"BeamE=1.96000000000000014e+01",1,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,80,0,0,-1,-1,-1,1,"pcr=3.75000000000000000e+00",1,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,80,0,0,-1,-1,-1,1,"La=5.36499999999999986e+01",1,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,80,0,0,-1,-1,-1,1,"M_alpha=3.72737929745092015e+03",1,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,80,0,0,-1,-1,-1,1,"M_Be8=7.45485043438848970e+03",1,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,80,0,0,-1,-1,-1,1,"M_Be7=6.53418366772819991e+03",1,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,80,0,0,-1,-1,-1,1,"M_D2=1.87561291385341997e+03",1,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,80,0,0,-1,-1,-1,1,"M_P=9.38272066718560040e+02",1,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,80,0,0,-1,-1,-1,1,"M_Li5=4.66761636363669277e+03",1,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,80,0,0,-1,-1,-1,1,"M_Li7=6.53383277448968965e+03",1,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,80,0,0,-1,-1,-1,1,"M_N=9.39565413351412985e+02",1,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,80,0,0,-1,-1,-1,1,"M_He5=4.66767970996292024e+03",1,(char*)NULL);

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_globalReconstruct() {
  G__cpp_setup_global0();
  G__cpp_setup_global1();
  G__cpp_setup_global2();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();

}

static void G__cpp_setup_func1() {
}

static void G__cpp_setup_func2() {
}

static void G__cpp_setup_func3() {
}

static void G__cpp_setup_func4() {
}

static void G__cpp_setup_func5() {
}

static void G__cpp_setup_func6() {
}

static void G__cpp_setup_func7() {
}

static void G__cpp_setup_func8() {
}

static void G__cpp_setup_func9() {
}

static void G__cpp_setup_func10() {
}

static void G__cpp_setup_func11() {
}

static void G__cpp_setup_func12() {
}

static void G__cpp_setup_func13() {
}

static void G__cpp_setup_func14() {
}

static void G__cpp_setup_func15() {
}

static void G__cpp_setup_func16() {
}

static void G__cpp_setup_func17() {
}

static void G__cpp_setup_func18() {

   G__resetifuncposition();
}

extern "C" void G__cpp_setup_funcReconstruct() {
  G__cpp_setup_func0();
  G__cpp_setup_func1();
  G__cpp_setup_func2();
  G__cpp_setup_func3();
  G__cpp_setup_func4();
  G__cpp_setup_func5();
  G__cpp_setup_func6();
  G__cpp_setup_func7();
  G__cpp_setup_func8();
  G__cpp_setup_func9();
  G__cpp_setup_func10();
  G__cpp_setup_func11();
  G__cpp_setup_func12();
  G__cpp_setup_func13();
  G__cpp_setup_func14();
  G__cpp_setup_func15();
  G__cpp_setup_func16();
  G__cpp_setup_func17();
  G__cpp_setup_func18();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__ReconstructLN_vectorlEdoublecOallocatorlEdoublegRsPgR = { "vector<double,allocator<double> >" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_string = { "string" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR = { "vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR = { "vector<TVirtualArray*,allocator<TVirtualArray*> >" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR = { "iterator<bidirectional_iterator_tag,TObject*,long,const TObject**,const TObject*&>" , 115 , -1 };
G__linked_taginfo G__ReconstructLN_SiHit = { "SiHit" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_SiHitcLcLSortByDetector = { "SiHit::SortByDetector" , 115 , -1 };
G__linked_taginfo G__ReconstructLN_vectorlEintcOallocatorlEintgRsPgR = { "vector<int,allocator<int> >" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<int,allocator<int> >::iterator>" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_SiHitcLcLSortByHit = { "SiHit::SortByHit" , 115 , -1 };
G__linked_taginfo G__ReconstructLN_vectorlESiHitcLcLSortByDetectorcOallocatorlESiHitcLcLSortByDetectorgRsPgR = { "vector<SiHit::SortByDetector,allocator<SiHit::SortByDetector> >" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_reverse_iteratorlEvectorlESiHitcLcLSortByDetectorcOallocatorlESiHitcLcLSortByDetectorgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<SiHit::SortByDetector,allocator<SiHit::SortByDetector> >::iterator>" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_vectorlESiHitcLcLSortByHitcOallocatorlESiHitcLcLSortByHitgRsPgR = { "vector<SiHit::SortByHit,allocator<SiHit::SortByHit> >" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_reverse_iteratorlEvectorlESiHitcLcLSortByHitcOallocatorlESiHitcLcLSortByHitgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<SiHit::SortByHit,allocator<SiHit::SortByHit> >::iterator>" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_PCHit = { "PCHit" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_PCHitcLcLSortByPC = { "PCHit::SortByPC" , 115 , -1 };
G__linked_taginfo G__ReconstructLN_vectorlEPCHitcLcLSortByPCcOallocatorlEPCHitcLcLSortByPCgRsPgR = { "vector<PCHit::SortByPC,allocator<PCHit::SortByPC> >" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_reverse_iteratorlEvectorlEPCHitcLcLSortByPCcOallocatorlEPCHitcLcLSortByPCgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<PCHit::SortByPC,allocator<PCHit::SortByPC> >::iterator>" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_SETTINGS = { "SETTINGS" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_SETTINGScLcLset_values = { "SETTINGS::set_values" , 115 , -1 };
G__linked_taginfo G__ReconstructLN_Track = { "Track" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_TrackcLcLTrackEvent = { "Track::TrackEvent" , 115 , -1 };
G__linked_taginfo G__ReconstructLN_TrackcLcLSilicon_Event = { "Track::Silicon_Event" , 115 , -1 };
G__linked_taginfo G__ReconstructLN_TrackcLcLPropCounter_Event = { "Track::PropCounter_Event" , 115 , -1 };
G__linked_taginfo G__ReconstructLN_vectorlETrackcLcLTrackEventcOallocatorlETrackcLcLTrackEventgRsPgR = { "vector<Track::TrackEvent,allocator<Track::TrackEvent> >" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_reverse_iteratorlEvectorlETrackcLcLTrackEventcOallocatorlETrackcLcLTrackEventgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Track::TrackEvent,allocator<Track::TrackEvent> >::iterator>" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_vectorlETrackcLcLSilicon_EventcOallocatorlETrackcLcLSilicon_EventgRsPgR = { "vector<Track::Silicon_Event,allocator<Track::Silicon_Event> >" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_reverse_iteratorlEvectorlETrackcLcLSilicon_EventcOallocatorlETrackcLcLSilicon_EventgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Track::Silicon_Event,allocator<Track::Silicon_Event> >::iterator>" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_vectorlETrackcLcLPropCounter_EventcOallocatorlETrackcLcLPropCounter_EventgRsPgR = { "vector<Track::PropCounter_Event,allocator<Track::PropCounter_Event> >" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_reverse_iteratorlEvectorlETrackcLcLPropCounter_EventcOallocatorlETrackcLcLPropCounter_EventgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Track::PropCounter_Event,allocator<Track::PropCounter_Event> >::iterator>" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_TVectorTlEfloatgR = { "TVectorT<float>" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_TVectorTlEdoublegR = { "TVectorT<double>" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_TGraph = { "TGraph" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_EnergyLoss = { "EnergyLoss" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_Reconstruct = { "Reconstruct" , 99 , -1 };
G__linked_taginfo G__ReconstructLN_ReconstructcLcLBe8Event = { "Reconstruct::Be8Event" , 115 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtableReconstruct() {
  G__ReconstructLN_vectorlEdoublecOallocatorlEdoublegRsPgR.tagnum = -1 ;
  G__ReconstructLN_string.tagnum = -1 ;
  G__ReconstructLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR.tagnum = -1 ;
  G__ReconstructLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__ReconstructLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR.tagnum = -1 ;
  G__ReconstructLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__ReconstructLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR.tagnum = -1 ;
  G__ReconstructLN_SiHit.tagnum = -1 ;
  G__ReconstructLN_SiHitcLcLSortByDetector.tagnum = -1 ;
  G__ReconstructLN_vectorlEintcOallocatorlEintgRsPgR.tagnum = -1 ;
  G__ReconstructLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__ReconstructLN_SiHitcLcLSortByHit.tagnum = -1 ;
  G__ReconstructLN_vectorlESiHitcLcLSortByDetectorcOallocatorlESiHitcLcLSortByDetectorgRsPgR.tagnum = -1 ;
  G__ReconstructLN_reverse_iteratorlEvectorlESiHitcLcLSortByDetectorcOallocatorlESiHitcLcLSortByDetectorgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__ReconstructLN_vectorlESiHitcLcLSortByHitcOallocatorlESiHitcLcLSortByHitgRsPgR.tagnum = -1 ;
  G__ReconstructLN_reverse_iteratorlEvectorlESiHitcLcLSortByHitcOallocatorlESiHitcLcLSortByHitgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__ReconstructLN_PCHit.tagnum = -1 ;
  G__ReconstructLN_PCHitcLcLSortByPC.tagnum = -1 ;
  G__ReconstructLN_vectorlEPCHitcLcLSortByPCcOallocatorlEPCHitcLcLSortByPCgRsPgR.tagnum = -1 ;
  G__ReconstructLN_reverse_iteratorlEvectorlEPCHitcLcLSortByPCcOallocatorlEPCHitcLcLSortByPCgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__ReconstructLN_SETTINGS.tagnum = -1 ;
  G__ReconstructLN_SETTINGScLcLset_values.tagnum = -1 ;
  G__ReconstructLN_Track.tagnum = -1 ;
  G__ReconstructLN_TrackcLcLTrackEvent.tagnum = -1 ;
  G__ReconstructLN_TrackcLcLSilicon_Event.tagnum = -1 ;
  G__ReconstructLN_TrackcLcLPropCounter_Event.tagnum = -1 ;
  G__ReconstructLN_vectorlETrackcLcLTrackEventcOallocatorlETrackcLcLTrackEventgRsPgR.tagnum = -1 ;
  G__ReconstructLN_reverse_iteratorlEvectorlETrackcLcLTrackEventcOallocatorlETrackcLcLTrackEventgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__ReconstructLN_vectorlETrackcLcLSilicon_EventcOallocatorlETrackcLcLSilicon_EventgRsPgR.tagnum = -1 ;
  G__ReconstructLN_reverse_iteratorlEvectorlETrackcLcLSilicon_EventcOallocatorlETrackcLcLSilicon_EventgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__ReconstructLN_vectorlETrackcLcLPropCounter_EventcOallocatorlETrackcLcLPropCounter_EventgRsPgR.tagnum = -1 ;
  G__ReconstructLN_reverse_iteratorlEvectorlETrackcLcLPropCounter_EventcOallocatorlETrackcLcLPropCounter_EventgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__ReconstructLN_TVectorTlEfloatgR.tagnum = -1 ;
  G__ReconstructLN_TVectorTlEdoublegR.tagnum = -1 ;
  G__ReconstructLN_TGraph.tagnum = -1 ;
  G__ReconstructLN_EnergyLoss.tagnum = -1 ;
  G__ReconstructLN_Reconstruct.tagnum = -1 ;
  G__ReconstructLN_ReconstructcLcLBe8Event.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtableReconstruct() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum_fwd(&G__ReconstructLN_vectorlEdoublecOallocatorlEdoublegRsPgR);
   G__get_linked_tagnum_fwd(&G__ReconstructLN_string);
   G__get_linked_tagnum_fwd(&G__ReconstructLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR);
   G__get_linked_tagnum_fwd(&G__ReconstructLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__ReconstructLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR);
   G__get_linked_tagnum_fwd(&G__ReconstructLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__ReconstructLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__ReconstructLN_SiHit),sizeof(SiHit),-1,262400,(char*)NULL,G__setup_memvarSiHit,G__setup_memfuncSiHit);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__ReconstructLN_SiHitcLcLSortByDetector),sizeof(SiHit::SortByDetector),-1,262144,(char*)NULL,G__setup_memvarSiHitcLcLSortByDetector,G__setup_memfuncSiHitcLcLSortByDetector);
   G__get_linked_tagnum_fwd(&G__ReconstructLN_vectorlEintcOallocatorlEintgRsPgR);
   G__get_linked_tagnum_fwd(&G__ReconstructLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__ReconstructLN_SiHitcLcLSortByHit),sizeof(SiHit::SortByHit),-1,262144,(char*)NULL,G__setup_memvarSiHitcLcLSortByHit,G__setup_memfuncSiHitcLcLSortByHit);
   G__get_linked_tagnum_fwd(&G__ReconstructLN_vectorlESiHitcLcLSortByDetectorcOallocatorlESiHitcLcLSortByDetectorgRsPgR);
   G__get_linked_tagnum_fwd(&G__ReconstructLN_reverse_iteratorlEvectorlESiHitcLcLSortByDetectorcOallocatorlESiHitcLcLSortByDetectorgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__ReconstructLN_vectorlESiHitcLcLSortByHitcOallocatorlESiHitcLcLSortByHitgRsPgR);
   G__get_linked_tagnum_fwd(&G__ReconstructLN_reverse_iteratorlEvectorlESiHitcLcLSortByHitcOallocatorlESiHitcLcLSortByHitgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__ReconstructLN_PCHit),sizeof(PCHit),-1,262400,(char*)NULL,G__setup_memvarPCHit,G__setup_memfuncPCHit);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__ReconstructLN_PCHitcLcLSortByPC),sizeof(PCHit::SortByPC),-1,262144,(char*)NULL,G__setup_memvarPCHitcLcLSortByPC,G__setup_memfuncPCHitcLcLSortByPC);
   G__get_linked_tagnum_fwd(&G__ReconstructLN_vectorlEPCHitcLcLSortByPCcOallocatorlEPCHitcLcLSortByPCgRsPgR);
   G__get_linked_tagnum_fwd(&G__ReconstructLN_reverse_iteratorlEvectorlEPCHitcLcLSortByPCcOallocatorlEPCHitcLcLSortByPCgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__ReconstructLN_SETTINGS),sizeof(SETTINGS),-1,262400,(char*)NULL,G__setup_memvarSETTINGS,G__setup_memfuncSETTINGS);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__ReconstructLN_SETTINGScLcLset_values),sizeof(SETTINGS::set_values),-1,262144,(char*)NULL,G__setup_memvarSETTINGScLcLset_values,G__setup_memfuncSETTINGScLcLset_values);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__ReconstructLN_Track),sizeof(Track),-1,262400,(char*)NULL,G__setup_memvarTrack,G__setup_memfuncTrack);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__ReconstructLN_TrackcLcLTrackEvent),sizeof(Track::TrackEvent),-1,262144,(char*)NULL,G__setup_memvarTrackcLcLTrackEvent,G__setup_memfuncTrackcLcLTrackEvent);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__ReconstructLN_TrackcLcLSilicon_Event),sizeof(Track::Silicon_Event),-1,262144,(char*)NULL,G__setup_memvarTrackcLcLSilicon_Event,G__setup_memfuncTrackcLcLSilicon_Event);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__ReconstructLN_TrackcLcLPropCounter_Event),sizeof(Track::PropCounter_Event),-1,262144,(char*)NULL,G__setup_memvarTrackcLcLPropCounter_Event,G__setup_memfuncTrackcLcLPropCounter_Event);
   G__get_linked_tagnum_fwd(&G__ReconstructLN_vectorlETrackcLcLTrackEventcOallocatorlETrackcLcLTrackEventgRsPgR);
   G__get_linked_tagnum_fwd(&G__ReconstructLN_reverse_iteratorlEvectorlETrackcLcLTrackEventcOallocatorlETrackcLcLTrackEventgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__ReconstructLN_vectorlETrackcLcLSilicon_EventcOallocatorlETrackcLcLSilicon_EventgRsPgR);
   G__get_linked_tagnum_fwd(&G__ReconstructLN_reverse_iteratorlEvectorlETrackcLcLSilicon_EventcOallocatorlETrackcLcLSilicon_EventgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__ReconstructLN_vectorlETrackcLcLPropCounter_EventcOallocatorlETrackcLcLPropCounter_EventgRsPgR);
   G__get_linked_tagnum_fwd(&G__ReconstructLN_reverse_iteratorlEvectorlETrackcLcLPropCounter_EventcOallocatorlETrackcLcLPropCounter_EventgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__ReconstructLN_TVectorTlEfloatgR);
   G__get_linked_tagnum_fwd(&G__ReconstructLN_TVectorTlEdoublegR);
   G__get_linked_tagnum_fwd(&G__ReconstructLN_TGraph);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__ReconstructLN_EnergyLoss),sizeof(EnergyLoss),-1,295168,(char*)NULL,G__setup_memvarEnergyLoss,G__setup_memfuncEnergyLoss);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__ReconstructLN_Reconstruct),sizeof(Reconstruct),-1,262400,(char*)NULL,G__setup_memvarReconstruct,G__setup_memfuncReconstruct);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__ReconstructLN_ReconstructcLcLBe8Event),sizeof(Reconstruct::Be8Event),-1,262144,(char*)NULL,G__setup_memvarReconstructcLcLBe8Event,G__setup_memfuncReconstructcLcLBe8Event);
}
extern "C" void G__cpp_setupReconstruct(void) {
  G__check_setup_version(30051515,"G__cpp_setupReconstruct()");
  G__set_cpp_environmentReconstruct();
  G__cpp_setup_tagtableReconstruct();

  G__cpp_setup_inheritanceReconstruct();

  G__cpp_setup_typetableReconstruct();

  G__cpp_setup_memvarReconstruct();

  G__cpp_setup_memfuncReconstruct();
  G__cpp_setup_globalReconstruct();
  G__cpp_setup_funcReconstruct();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfuncReconstruct();
  return;
}
class G__cpp_setup_initReconstruct {
  public:
    G__cpp_setup_initReconstruct() { G__add_setup_func("Reconstruct",(G__incsetup)(&G__cpp_setupReconstruct)); G__call_setup_funcs(); }
   ~G__cpp_setup_initReconstruct() { G__remove_setup_func("Reconstruct"); }
};
G__cpp_setup_initReconstruct G__cpp_setup_initializerReconstruct;

